<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java_inerview</title>
    <link href="/2025/04/23/Java-inerview/"/>
    <url>/2025/04/23/Java-inerview/</url>
    
    <content type="html"><![CDATA[<h1 id="java面试笔记">java面试笔记</h1><h2 id="redis">Redis</h2><h3 id="缓存穿透">缓存穿透</h3><p>查询一个不存在的数据，mysql查不到也不会写缓存，导致每次请求都查数据库</p><p>解决方法：布隆过滤器</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
      <tag>mysql</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java_note</title>
    <link href="/2024/10/11/Java-note/"/>
    <url>/2024/10/11/Java-note/</url>
    
    <content type="html"><![CDATA[<h1 id="java-note">Java Note</h1><h2 id="输入输出">输入输出</h2><h3 id="普通输入输出">普通输入输出</h3><p>nextInt()和next()都会自动跳过前面遗留的结束符（<strong>空格键、Tab键或Enter键</strong>）</p><p>而nextLine()会读取遗留的结束符</p><h4 id="单变量">单变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nu</span> <span class="hljs-operator">=</span> cin.nextInt(); <span class="hljs-comment">//int类型</span><br>        System.out.println(nu);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">fl</span> <span class="hljs-operator">=</span> cin.nextFloat(); <span class="hljs-comment">//float类型</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">dou</span> <span class="hljs-operator">=</span> cin.nextDouble(); <span class="hljs-comment">//double类型</span><br><span class="hljs-type">char</span> <span class="hljs-variable">change</span> <span class="hljs-operator">=</span> cin.next().charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">//char类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> cin.next(); <span class="hljs-comment">//String类型,遇到空格结束</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> cin.nextLine(); <span class="hljs-comment">//String类型,读取一行数据，遇到换行结束。类似gets</span><br>        cin.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输入数据个数或行数未知">输入数据个数或行数未知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (sc.hasNextInt()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            System.out.println(num);<br>        &#125;<br>        sc.nextLine();  <span class="hljs-comment">// 读取数字后面的换行</span><br>        <span class="hljs-keyword">while</span> (sc.hasNextLine()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.nextLine();<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="逗号分隔的数组">逗号分隔的数组</h4><p><em>input:</em> <em>5</em> <em>11,12,13,14,15</em></p><p><em>output:</em> <em>11,12,13,14,15</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1.new一个 Scanner 对象</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 2.整数使用 nextInt();</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-comment">// 3.nextLine()表示读取一行作为字符串，这里读取 n 后面的换行符</span><br>        sc.nextLine();<br><br>        <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 4.数组作为一个字符串输入，并按照逗号切分，每个数字以 String 类型存储</span><br>        <span class="hljs-comment">// 4.1 扩展：sc.next()也是读取字符串，但是不是以换行分割，而是以空格分割</span><br>        String[] input = sc.nextLine().split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-comment">// 5.String 转 int</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            nums[i] = Integer.parseInt(input[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 6.输出。print()仅输出内容，println输出内容并换行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            System.out.print(nums[i]);<br>            <span class="hljs-keyword">if</span> (i != n - <span class="hljs-number">1</span>) System.out.print(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="格式化输出">格式化输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DecimalFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 方法一：String的format方法（推荐）</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">111231.5585</span>;<br>        <span class="hljs-comment">// 保留 2 位小数（有四舍五入）</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, f));<br><br>        <span class="hljs-comment">// 方法二：DecimalFormat的format方法</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">111231.5585</span>;<br>        <span class="hljs-type">DecimalFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalFormat</span>(<span class="hljs-string">&quot;#.00&quot;</span>);<br>        System.out.println(df.format(f));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速输入输出">快速输入输出</h3><h4 id="bufferedreaderwriter">BufferedReader/Writer</h4><ul><li><p>read() 方法用于读取单个字符，返回该字符的整数表示（即字符的Unicode值）。如果到达流的末尾，返回 -1。</p></li><li><p>write() 不能直接输出int类型， 因为write(int a)会输出其对应的ASCii码的字符</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>         <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">cout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-number">66</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> cin.read();   <span class="hljs-comment">// read()只读取一个字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> cin.read();   <span class="hljs-comment">// 吸收 \n</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cin.read();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> cin.readLine();   <br>        <span class="hljs-comment">// readLine()会将&quot;\n\r&quot;全部吸收,所以只需要一个readLine()来吸收回车</span><br>        cout.write(Integer.toString(a1));<br>        cout.write(<span class="hljs-string">&quot;\n&quot;</span>);<br>        cout.write(b + <span class="hljs-string">&quot;\n&quot;</span>);<br>        cout.flush();  <span class="hljs-comment">// 此时才会真正触发输出</span><br>        cin.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="streamtokenizerprintwriter">StreamTokenizer/PrintWriter</h4><ul><li>StreamTokenizer只能接收数字或字母，如果输入除空格和回车以外的字符（如：!@#$%^&amp;*()<span></span>)无法识别，会显示null。</li><li>如果标记是字符串，用st.sval获取标记，如果是数字用st.nval获取标记，st.navl是double类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StreamTokenizer</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTokenizer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in)));<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">cout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nextInt();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nextLong();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> nextDouble();<br>        cout.println(n);<br>        cout.println(m);<br>        cout.println(d);<br>        cout.flush();<br>      <br>        closeAll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        cin.nextToken();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) cin.nval;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextLong</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        cin.nextToken();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) cin.nval;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        cin.nextToken();<br>        <span class="hljs-keyword">return</span> cin.nval;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">nextString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        cin.nextToken();<br>        <span class="hljs-keyword">return</span> cin.sval;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cout.close();<br>        in.close();<br>        out.close();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多组输入">多组输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">StreamTokenizer</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamTokenizer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in)));<br>    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out));<br><br>    <span class="hljs-keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) in.nval;<br>        in.nextToken();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) in.nval;<br>        out.println(n+<span class="hljs-string">&quot; &quot;</span>+m);<br>        out.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组">数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">dataType[] arrayRefVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataType</span>[arraySize];<br>dataType[][] arrayRefVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataType</span>[arraySize][arraySize];<br><br><span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>Arrays.fill(Type[] array, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex, Type value) <span class="hljs-comment">//数组填充默认值</span><br><br>System.arraycopy(<span class="hljs-type">int</span>[] src, <span class="hljs-type">int</span> start1,<span class="hljs-type">int</span>[] dest, <span class="hljs-type">int</span> start2, length);<br><br><span class="hljs-type">int</span> new_array[] = Arrays.copyOf(dataType[] srcArray,<span class="hljs-type">int</span> new_length);<br></code></pre></td></tr></table></figure><h2 id="哈希表">哈希表</h2><h3 id="hashmap">HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; map= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;string1&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.replace(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Wiki&quot;</span>);<br><br>map.get(<span class="hljs-number">1</span>); <br><span class="hljs-comment">// 找不到，返回null</span><br>map.getOrDefault(Object key, V defaultValue)<br><span class="hljs-comment">// 找不到key，返回defaultValue</span><br><br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>&#125;<br><span class="hljs-comment">// 迭代键</span><br><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Key = &quot;</span> + key);<br>&#125;<br><span class="hljs-comment">// 迭代值</span><br><span class="hljs-keyword">for</span> (Integer value : map.values()) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Value = &quot;</span> + value);<br>&#125;<br><br><span class="hljs-comment">//lambda遍历</span><br>map.forEach((key, value) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Key: &quot;</span> + key + <span class="hljs-string">&quot;, Value: &quot;</span> + value);<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">方法</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td><td style="text-align: left;">删除 hashMap 中的所有键/值对</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td style="text-align: left;">复制一份 hashMap</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td style="text-align: left;">判断 hashMap 是否为空</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td style="text-align: left;">计算 hashMap 中键/值对的数量</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td style="text-align: left;">将键/值对添加到 hashMap 中</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td><td style="text-align: left;">将所有键/值对添加到 hashMap 中</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td><td style="text-align: left;">如果 hashMap中不存在指定的键，则将指定的键/值对插入到 hashMap 中。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td style="text-align: left;">删除 hashMap 中指定键 key 的映射关系</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td><td style="text-align: left;">检查 hashMap 中是否存在指定的 key对应的映射关系。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td><td style="text-align: left;">检查 hashMap 中是否存在指定的 value对应的映射关系。</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td style="text-align: left;">替换 hashMap 中是指定的 key 对应的value。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td><td style="text-align: left;">将 hashMap中的所有映射关系替换成给定的函数所执行的结果。</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td style="text-align: left;">获取指定 key 对应对 value</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td><td style="text-align: left;">获取指定 key 对应对 value，如果找不到 key，则返回设置的默认值</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td><td style="text-align: left;">对 hashMap中的每个映射执行指定的操作。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td style="text-align: left;">返回 hashMap中所有映射项的集合集合视图。</td></tr><tr class="odd"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td style="text-align: left;">返回 hashMap 中所有 key组成的集合视图。</td></tr><tr class="even"><td style="text-align: left;"><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td style="text-align: left;">返回 hashMap 中存在的所有 value 值。</td></tr></tbody></table><h3 id="hashset">HashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; hashset= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>hashset.add(<span class="hljs-number">1</span>);<br>hashset.contains(<span class="hljs-number">1</span>); <span class="hljs-comment">//判断元素是否存在</span><br>hashset.remove(<span class="hljs-number">1</span>);<br>hashset.clear();<br>hashset.size()<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> number : hashset) &#123;<br>    <span class="hljs-comment">//遍历</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="list">List</h3><figure><img src="/2024/10/11/Java-note/Java-list-interface.png" alt="在Java中实现List接口的类"><figcaption aria-hidden="true">在Java中实现List接口的类</figcaption></figure><h4 id="arraylist">ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>add() - 将元素添加到列表</li><li>addAll(ArrayList) - 将一个列表的所有元素添加到另一个</li><li>get(index) - 有助于从列表中随机访问元素</li><li>set(<em>index, element</em>) - 更改列表的元素</li><li>remove(Object obj) - 从列表中删除一个元素</li><li>remove(int index) - 从列表中删除一个元素</li><li>clear() - 从列表中删除所有元素（比removeAll()效率更高）</li><li>size() - 返回列表的长度</li><li>contains() - 如果列表包含指定的元素，则返回true</li><li>indexOf()</li><li>isEmpty()</li></ul><h4 id="stack">Stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Type&gt; stacks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>Object push()</li><li>Object pop()</li><li>int search(Object)</li><li>boolean isEmpty()</li><li>Object peek( )</li></ul><h3 id="queue">Queue</h3><h4 id="arraydeque双端队列">ArrayDeque双端队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Deque&lt;Type&gt; animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li><p>add()/addLast()</p><p>addFirst()</p></li><li><p>boolean offer()/offerLast()</p><p>boolean offerFirst()</p><p><strong>成功插入元素,返回true;如果双端队列已满,返回false</strong></p></li><li><p>Object getFirst()/peek()</p><p>Object getLast()</p></li><li><p>removeFirst()/remove()</p><p>删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常pollFirst()/poll()</p><p>删除第一个元素，并返回删除元素的值，如果元素为null，将返回nullremoveLast()</p><p>删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常pollLast()</p><p>删除最后一个元素，并返回删除元素的值，如果为null，将返回null</p><p>removeFirstOccurrence(Object o)</p><p>删除第一次出现的指定元素</p><p>removeLastOccurrence(Object o)</p><p>删除最后一次出现的指定元素</p></li><li><p>size() 获取队列中元素个数</p></li><li><p>isEmpty() 判断队列是否为空</p></li><li><p>contain(Object o) 判断队列中是否存在该元素</p></li><li><p>toArray() 转成数组</p></li><li><p>clear() 清空队列</p></li><li><p>栈操作</p><p>push(E e) 栈顶添加一个元素</p><p>pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</p></li></ul><h4 id="priorityqueue优先级队列">PriorityQueue优先级队列</h4><p>默认小根堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li><p>add()/offer()</p></li><li><p>peek()</p></li><li><p>remove()/poll()</p></li><li><p>contains()</p></li><li><p>size()</p></li><li><p>toArray()</p></li><li><p>比较器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lambda</span><br>PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; &#123;<span class="hljs-keyword">return</span> o2 - o1;&#125;));<br><br><span class="hljs-comment">//常规写法</span><br>PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2 - o1;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="arrays">Arrays</h2><h3 id="判断数组相等">判断数组相等</h3><p><code>Arrays.equals(ary, ary1)</code></p><h3 id="排序">排序</h3><p><code>Arrays.sort（s[,Comparator]）</code></p><ul><li>针对数据类型（基本数据类型和引用对象类型）的数组元素</li><li>自定义排序Comparator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;student&gt; comparatorAge =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span> &lt;student&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(student p1,student p2)</span>&#123;<br>        <span class="hljs-keyword">if</span> (p1.getAge()&gt;p2.getAge())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.getAge()&lt;p2.getAge())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br>Arrays.sort(s,comparatorAge);<br></code></pre></td></tr></table></figure><h2 id="collections">Collections</h2><h3 id="sort">sort</h3><p><code>Collections.sort(s[,Comparator])</code></p><ul><li>针对集合框架中的动态数组，链表，树，哈希表等</li><li>自定义排序Comparator</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(people, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123; <br> <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person p1, Person p2)</span> &#123;  <br>     <span class="hljs-comment">// 按照年龄升序排序  </span><br>     <span class="hljs-keyword">return</span> p1.getAge() - p2.getAge();  <br> &#125;  <br>&#125;);  <br><br></code></pre></td></tr></table></figure><p>在Comparator接口的compare方法中，返回值遵循以下约定：</p><ul><li>返回值小于0，第一个对象（o1）排在第二个对象（o2）之前。</li><li>返回值等于0，则表示两个对象是相等的，它们的顺序无关紧要。</li><li>返回值大于0，第一个对象（o1）排在第二个对象（o2）之后。</li></ul><h5 id="lambda表达式比较java-8">lambda表达式比较(Java 8)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(people, (p1, p2) -&gt; p1.getAge() - p2.getAge());<br></code></pre></td></tr></table></figure><h3 id="reverse">reverse</h3><p><code>Collections.reverse(list);</code></p><h3 id="shuffle">shuffle</h3><p><code>Collections.shuffle(list);</code></p><h3 id="max">max</h3><p><code>Collections.max(list)/min(list);</code></p><h3 id="swap">swap</h3><p><code>Collections.swap(list,3,4);</code></p><h2 id="string">String</h2><ul><li><p>s.length()</p><p><strong>length不是方法，是数组的属性</strong></p><p><strong>length()是字符串String的一个方法</strong></p></li><li><p>string1.concat(string2);</p></li><li><p>格式化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String fs;<br>fs = String.format(<span class="hljs-string">&quot;浮点型变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot;%f, 整型变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot; %d, 字符串变量的值为 &quot;</span> +<br>                   <span class="hljs-string">&quot; %s&quot;</span>, floatVar, intVar, stringVar);<br></code></pre></td></tr></table></figure></li><li><p>char charAt(int index)</p></li><li><p>boolean equals(Object anObject)</p></li><li><p>int compareTo(String anotherString)</p><ul><li>如果参数字符串等于此字符串，则返回值 0；</li><li>如果此字符串小于字符串参数，则返回一个小于 0 的值；</li><li>如果此字符串大于字符串参数，则返回一个大于 0 的值。</li></ul></li><li><p>boolean endsWith(String suffix)</p></li><li><p>boolean startsWith(String prefix, [int toffset])</p></li><li><p>String replace(char searchChar, char newChar)</p></li><li><p>String substring(int beginIndex, int endIndex)</p></li><li><p>String toLowerCase()</p></li><li><p>String toUpperCase()</p></li><li><p>boolean contains(CharSequence chars)</p></li><li><p>char[] toCharArray()</p></li><li><p>String.valueOf(char[] data) : 将char转换成字符串</p></li><li><p>String trim()</p></li><li><p>boolean isEmpty()</p></li></ul><p><strong>index</strong></p><ul><li>int indexOf(int ch):返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回-1。</li><li>int indexOf(int ch, int fromIndex): 返回从 fromIndex位置查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回-1。</li><li>int indexOf(String str)</li><li>int indexOf(String str, int fromIndex)</li></ul><h3 id="split">split</h3><p><code>public String[] split(String regex, int limit)</code></p><ul><li><strong>regex</strong> -- 正则表达式分隔符。</li><li><strong>limit</strong> -- 分割的份数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">str.split(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="math">Math</h2><h3 id="math.max"><code>Math.max()</code></h3><h3 id="math.powdouble-m-double-n"><code>Math.pow(double m, double n)</code></h3><p>m^n</p>]]></content>
    
    
    <categories>
      
      <category>programing language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2024/09/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/09/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划">动态规划</h2><h3 id="背包">0-1背包</h3><ol type="1"><li><p>二维dp</p><ul><li><p>先遍历物品还是先遍历背包重量都可以</p><figure><img src="/2024/09/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20240910092836809.png" alt="image-20240910092836809"><figcaption aria-hidden="true">image-20240910092836809</figcaption></figure></li></ul></li><li><p>一维dp</p><ul><li><p>背包容量必须倒序遍历，保证物品i只被放入一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>必须先遍历物品再遍历容量，否则同一物品会被多次放入</p></li></ul></li></ol><h3 id="完全背包">完全背包</h3><p><strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><ol type="1"><li><p>一维dp</p><ul><li><p>两个for循环嵌套顺序是无所谓的(因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>求凑出来的方案个数</p></li></ol><ul><li><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p></li><li><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IELTS_Writing</title>
    <link href="/2024/08/13/IELTS-Writing/"/>
    <url>/2024/08/13/IELTS-Writing/</url>
    
    <content type="html"><![CDATA[<h1 id="task-1">Task 1</h1><h3 id="paragraphs">4 paragraphs</h3><h4 id="introduction">1. introduction</h4><ul><li>paraphrase the question</li></ul><h4 id="overview">2. overview</h4><ul><li>the main, general things</li><li>2 sentences, 2 points</li></ul><h4 id="details">3. details</h4><h4 id="details-1">4. details</h4><p><strong>no conclusion!</strong></p><h2 id="similar-chart">4 similar chart</h2><ol type="1"><li>line graph</li><li>bar chart</li><li>pie chart</li><li>table</li></ol><h2 id="mixed-chart">mixed chart</h2><h4 id="describe">describe</h4><ol type="1"><li><p>one main feature in each chart</p></li><li><p>describe specific numbers for each chart separately</p></li></ol><h4 id="details-paragraph">details paragraph</h4><h5 id="key-phrases">key phrases</h5><ul><li>According to the bar chart / Looking at the ... pie chart, ...</li></ul><h2 id="diagram---comparing">Diagram - comparing</h2><h3 id="overview-1">overview</h3><p>main changes and unchanged places</p><h3 id="phrases">phrases</h3><ul><li>existing plan <span class="math inline">\(\rightarrow\)</span>current layout</li><li>there will no longer be</li><li>there will be achieved by removing</li><li>will be installed/replaced</li><li>when the building work has been done</li></ul><h2 id="flow-diagram---process">Flow Diagram - process</h2><h3 id="step">step</h3><ol type="1"><li>Overview: how many steps and main materials</li><li>Details: each step in the process</li></ol><h3 id="steps-language">'steps' language</h3><ul><li><p>it requires five stages / consists of four distinctstages</p></li><li><p>raw materials</p></li><li><p>at the first stage in the process</p></li><li><p>the process begin with</p></li><li><p>secondly, finally</p></li><li><p>the second step involves</p></li><li><p>next, then, after that</p></li><li><p>at the following/third stage</p></li></ul><h3 id="passive-verbs">passive verbs</h3><ul><li><p>e.g. glass is visited</p></li><li><p>使用passive verbs表示下一过程</p><figure><img src="/2024/08/13/IELTS-Writing/image-20240730133751464.png" alt="image-20240730133810390"><figcaption aria-hidden="true">image-20240730133810390</figcaption></figure></li></ul><h2 id="good-phases">good phases</h2><ol type="1"><li>by far the most important ... over the period shown.</li><li>in terms of ...</li><li>by contrast</li><li>a negligible amount</li><li>sth. overtake / surpass sth.</li><li>rise dramatically to a peak of<br></li><li>remain at this level</li><li>respectively</li><li>rise by a a similar amount</li><li>sales figures</li><li>approximately / close to</li><li>the equivalent figure for</li><li>company/year(2013...) <strong>saw</strong> an increase in/a riseof</li><li>than their New Zealand <strong>counterparts</strong></li><li>sth. <strong>accounted for</strong> the highest proportion</li><li>the second most visited country</li><li>ranked fifth</li><li>despite falling numbers</li><li>be in the majority/minority(the majority of ...)</li><li>to be precise</li><li>a mere 15 people(a mere = only / a full /...)</li><li>增加：increase/raise/go up/grow up+X times</li><li>减少：decrease/reduce/decline/drop/go down+X times</li><li>The total output of industry in 2003 was 40 times as high as<strong>that of</strong> 1970.</li><li>be double / triple that of / the number of...</li><li>someone spent half as much in relative terms on sth. as otherone.</li></ol><h1 id="task2">Task2</h1><h2 id="type">Type</h2><table><thead><tr class="header"><th></th><th>Group1 - opinion</th></tr></thead><tbody><tr class="odd"><td></td><td>agree/disagree</td></tr><tr class="even"><td></td><td>discuss both views and give your opinion</td></tr><tr class="odd"><td></td><td>positive/negative development</td></tr><tr class="even"><td></td><td>advantages outweigh the disadvantages?</td></tr></tbody></table><table><thead><tr class="header"><th></th><th>Group2 - analysis</th></tr></thead><tbody><tr class="odd"><td></td><td>Problems/Causes/Reasons and Solutions</td></tr></tbody></table><h2 id="group1---opinion">Group1 - opinion</h2><h3 id="simons-structure">Simon’s Structure</h3><h4 id="introduction-1">Introduction</h4><p>(background)</p><p>I strongly hold that (our response).</p><h4 id="paragraph-1">Paragraph 1</h4><p>On the one hand, I believe that ...</p><p>Firstly,secondly,finally...</p><p>To be more specific, (fact 1-2);</p><p>Not to mention that, (fact 1-3).</p><h5 id="exemplification">Exemplification</h5><p>Furthermore, the fact that (point 2 mid level) indicates that (ourresponse).</p><p>Take the case of (character), who / which (process). As a result,(result).</p><p>Had it not been for sth.(process paraphrase), (character) would never(result paraphrase).</p><h4 id="paragraph-2">Paragraph 2</h4><p>However,...</p><p>The main reason is that...</p><p>Another key benefit of ... is ...</p><p>A final point is that ...</p><h5 id="concession">Concession</h5><p>Nevertheless, a voice arises that (<strong>opposite</strong> responseand point in grand <strong>opening</strong>).</p><p>Ironically, (facts against opposite detail).</p><p>Therefore, (point 3).</p><h4 id="conclusion">Conclusion</h4><p>In conclusion, I disagree with the view that...</p><h2 id="group2---analysis">Group2 - analysis</h2><h3 id="structure">Structure</h3><ol type="1"><li>introduction</li><li>causes</li><li>solutions</li><li>conclusion: summarize the problem and steps</li></ol><h3 id="paragraphs-1">4 Paragraphs</h3><h4 id="introduction-2">introduction</h4><ol type="1"><li>rewrite the problem</li><li>"There are a variety of possible reasons for this, but steps candefinitely be taken to tackle the problem."</li></ol><h4 id="causes">causes</h4><h5 id="template">template</h5><p>In my opinion, three main factors are blame for ...</p><h6 id="连接词">连接词</h6><ul><li>first</li><li>secondly</li><li>...</li></ul><h4 id="solutions">solutions</h4><h5 id="template-1">template</h5><p>... can certainly be improved.</p><p>(solution与三个causes一一对应)</p><h6 id="连接词-1">连接词</h6><ul><li>the change must start with ...</li><li>Also,...</li><li>At the same time,...</li></ul><h4 id="conclusion-1">conclusion</h4><h5 id="image-20240804151655848"><img src="/2024/08/13/IELTS-Writing/image-20240804151655848.png" alt="image-20240804151655848"></h5><h3 id="good-phrases">good phrases</h3><ul><li>steps can be taken to tackle the problem</li><li>three main factors are to blame</li><li>face discipline problems</li><li>play an important role in</li></ul><h2 id="观点库">观点库</h2><figure><img src="/2024/08/13/IELTS-Writing/image-20240801150234197.png" alt="image-20240801150234197"><figcaption aria-hidden="true">image-20240801150234197</figcaption></figure><h3 id="technology">technology</h3><ul><li>The rapid economic progress has <strong>changed China beyondrecognition</strong>.</li><li>study whenever and whatever they want</li><li>institute should supplement traditional teaching with the use oftechnology</li></ul><h3 id="cities">Cities</h3><ul><li>cities offer greater employment possibilities and a higher standardof living</li><li>people migrate to cities from countryside</li><li>life in cities has its drawbacks</li><li>the cost of living is higher then in rural areas</li><li>cities lack a sense of community</li></ul><h3 id="education">Education</h3><h4 id="advantages">advantages</h4><ul><li><p>They can contribute positively to society</p></li><li><p>schools aim to teach young people moral values such as toleranceand sharing</p></li><li><p>schools prepare children to be members of society</p></li><li><p>the best universities employ teachers who are experts in theirfields</p></li><li><p>Qualifications gained abroad/A degree can open the door to betterjob opportunities</p></li><li><p>broaden students' horizons</p></li><li><p>skilled workers are needed such as ...</p></li><li><p>Repetitive manual jobs are now almost done by machine</p></li></ul><h4 id="drawbacks">drawbacks</h4><ul><li>students has problems with paperwork such as visa applications</li><li>language barrier</li><li>living alone in an unfamiliar culture can cause homesickness</li></ul><h3 id="environment">Environment</h3><ul><li>The increasing world population is putting pressure on naturalresources</li></ul><h3 id="family">Family</h3><ul><li><p>Many fathers and mothers share their parenting and domesticresponsibilities</p></li><li><p>contribute equally to childcare, cooking and cleaning</p></li></ul><h2 id="vinces-structure">Vince's Structure</h2><h3 id="key-elements">Key elements</h3><ol type="1"><li>5 paragraphs</li><li>350+ words</li></ol><h3 id="structure-1">Structure</h3><h4 id="argument">Argument</h4><ul><li>The Beginning</li><li>Point 1 + Reasoning</li><li>Point 2 + Exemplification</li><li>Point 3 + Concession</li><li>The End</li></ul><h5 id="tips">tips</h5><ul><li>point尽量偏向宏观，便于拓展</li><li>论点之间的逻辑关系必须紧密流畅</li></ul><h3 id="paragraphs-2">5 paragraphs</h3><h4 id="the-beginning">1. The Beginning</h4><h5 id="template-2">template</h5><p>It is hard to deny that (opposite detail). Such a fact leadsimpressionable people to generate the opinion that (oppositeresponse).</p><p>However, such a statement suffers from both logical and factualfallacies, and it should be examined meticulously.</p><p>As far as (Point 1), (Point 2) and (Point 3) are concerned, Istrongly hold that (our response).</p><h5 id="key-phrases-1">key phrases</h5><figure><img src="/2024/08/13/IELTS-Writing/image-20240802145717913.png" alt="image-20240802145717913"><figcaption aria-hidden="true">image-20240802145717913</figcaption></figure><ul><li><strong>appears</strong> adj.</li><li><strong>simply</strong> due to...</li></ul><h4 id="reasoning">2. Reasoning</h4><h5 id="three-stages">three stages</h5><p>层层递进，宏观<span class="math inline">\(\rightarrow\)</span>微观</p><figure><img src="/2024/08/13/IELTS-Writing/image-20240802150240500.png" alt="image-20240802150240500"><figcaption aria-hidden="true">image-20240802150240500</figcaption></figure><h5 id="template-3">template</h5><p>First and foremost, (point 1), as (fact 1-1).</p><p>For instance / To illustrate / To be more specific, (fact 1-2);</p><p>In addition / Not to mention that / Furthermore, (fact 1-3).</p><p>(Optional filler: 字数不足补充：summary/conclusion/what if/a smallexample)</p><h5 id="tip">tip</h5><ul><li>所有fact必须服务于point 1，不能跑题</li></ul><h4 id="exemplification-1">3. Exemplification</h4><h5 id="template-4">template</h5><p>Furthermore, the fact that (point 2 mid level) indicates that (ourresponse).</p><p>Take the case of (character), who / which (process). As a result,(result).</p><p>Had it bot been for (process paraphrase), (character) would never(result paraphrase).</p><h5 id="example">Example</h5><figure><img src="/2024/08/13/IELTS-Writing/image-20240803140936287.png" alt="image-20240803140936287"><figcaption aria-hidden="true">image-20240803140936287</figcaption></figure><h4 id="concession-1">Concession</h4><h5 id="template-5">template</h5><p>Nevertheless, a voice arises that (<strong>opposite</strong> responseand point in grand <strong>opening</strong>).</p><p>Ironically, (facts against opposite detail).</p><p>Therefore, (point 3).</p><h4 id="ending">Ending</h4><h5 id="template-6">template</h5><p>In a nutshell, I maintain that (response paraphrase of point1,2,3).</p><p>Admittedly, as my favorite quote from Leibniz goes, there are no twoidentical leaves in the world. Everyone has their own unique perspectiveand some people may oppose me.</p><p>However, I believe they will compromise after being exposed to myarticle.</p><h5 id="tips-1">tips</h5><ul><li>points的论述禅师必须详细且通顺</li></ul>]]></content>
    
    
    <categories>
      
      <category>IELTS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IELTS</tag>
      
      <tag>writing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IELTS_Speaking</title>
    <link href="/2024/08/13/IELTS-Speaking/"/>
    <url>/2024/08/13/IELTS-Speaking/</url>
    
    <content type="html"><![CDATA[<h3 id="年轻人的偶像比赛赢家鼓励你达成目标的人好消息别人做的好决定">年轻人的偶像，比赛赢家，鼓励你达成目标的人,好消息，别人做的好决定</h3><p>I’d like to talk about a cyclist, Mark Cavendish, born in 1985 on theIsle of Man in the UK, known as the "Manx Missile" for his incrediblesprinting speed. He joined professional cycling in 2005 and quicklydominated the sprint stages of the Tour de France, winning multiplestages and silencing the critics. However, an accident near the finishand the EB virus significantly affected his career. In 2020, he thoughthis career was over in an interview after a competiton.</p><p>In 2021, thanks to Specialized, a bike manufacturer as well as thesponsor, he rejoined the Quick-Step team. In the fourth stage, he won aTour de France stage beyond expection for the first time in five years,equaling Eddy Merckx's record of 34 stage wins.</p><p>This year in July, in the fifth stage, 39-year-old Cavendish achievedhis 35th career stage victory, surpassing Merckx's world record, makinghim the rider with the most stage victories in Tour de Francehistory.</p><p>From sprint king to overcoming frustrations and making history,Cavendish embodies the relentless pursuit of victory and dedication tospeed.</p><h3 id="看过但想参加的运动">看过但想参加的运动</h3><p>I’d like to talk about a sport I watched and would like to try, whichis cycling, particularly inspired by Mark Cavendish. I watched Tour deFrance just before this summer vacation, in my dormitory, on thevideo-shar</p><p>ing website Bilibili.</p><p>I decided to watch it because my roommate recommended it. He is acycling enthusiast and often talks about various cyclists and theirachievements. He was particularly excited about Mark Cavendish and hisincredible comeback in the Tour de France, which made me curious to seewhat exactly attracts him so much.</p><p>So I watched it with my roommate, who provided lots of interestinginsights and background information about the race and the cyclists. Hisenthusiasm was quite contagious and made the experience even moreenjoyable.</p><p>As for whether I will do it in the future, I think I would like togive it a try. Watching the race and seeing the determination and skillof the cyclists, especially Mark Cavendish, was very inspiring. It seemslike a great way to stay fit and enjoy the outdoors.</p><p>Overall, I felt very excited and motivated after watching the race.From sprint king to overcoming frustrations and making history,Cavendish embodies the relentless pursuit of victory and dedication tospeed, which are qualities I admire and would like to embody in my ownlife.</p><h3 id="想学的技能">想学的技能</h3><p>I‘d like to talk about something I would like to learn in the future,which is bicycle repair. Learning how to fix a bike would be incrediblyuseful for me.</p><p>I want to learn bike repair because, in high school, I used to ridemy bike to school. The route I took passed by a construction site, andthe small road next to it was always covered with gravel and brokenglass. I had flat tires at least ten times because of this. Every time,I had to go to a repair shop, which sometimes made me late for school.Learning to fix my bike would save time and money, and it would be veryconvenient.</p><p>I’d probably start learning online, where there are plenty ofdetailed videos and step-by-step guides. Then, I’d practice what I learnin our dorm room, with my roommate giving me tips and advice. He’s acycling enthusiast and knows a lot about bike maintenance. His hands-onexperience would be really valuable.</p><p>I don’t think it’s very difficult to learn. It might take somepractice to get the hang of it, but with good online resources and helpfrom my roommate, I’m confident I can learn it. Plus, I enjoy workingwith my hands and solving problems, so it should be a fun and rewardingskill to acquire.</p><h3 id="音乐爱好者">音乐爱好者</h3><p>I’d like to talk about my roommate, who thinks music is veryimportant and truly enjoys it. We've been living together for threeyears now. I first met him when I started university, and he walked intoour dorm carrying an electric guitar. Almost every day after classes, hepractices his guitar in our dorm room. For us, it seems hard and tired,but for him, it seems to be a form of enjoyment and relaxation.</p><p>He plays various mainstream genres of music, but he is especiallykeen on jazz and rock. His passion for these genres is evident in theway he plays, with a lot of energy and enthusiasm. He believes music isimportant because it provides a way to express emotions, relieve stress,and connect with others. Music, for him, is a universal language thattranscends barriers and brings people together.</p><p>I feel quite inspired by him. His dedication to music and hisrelentless practice have shown me the importance of having a passion andpursuing it diligently. It’s impressive to see someone so committed totheir craft, and it has motivated me to find something I’m equallypassionate about. Overall, living with him has been a positiveexperience, and I've developed a deeper appreciation for music thanks tohim.</p><h3 id="爱豆的电影角色">爱豆的电影角色</h3><p>I’d like to talk about a film character played by an actor I admire,Rowan Atkinson. I have been a fan of Mr. Bean since I was young. I don'tremember the exact date I first saw his work, but I used to watch "Mr.Bean" almost every week.</p><p>In the movie, Bean The Ultimate Disaster, who he played is anordinary security guard at the National Gallery in London. By a mistake,he gets the chance to travel to Los Angeles on a work assignment. He'sexpected to act as an art history expert from Britain and give a speechat the unveiling of a famous painting. The curator of the museum in LAinvites Mr. Bean to stay at his home, but Mr. Bean’s ridiculous behaviorand odd way of thinking nearly tear the curator’s family apart.</p><p>Things get even worse when Mr. Bean accidentally ruins the painting,putting the curator’s career and reputation at risk. Fortunatelly, Mr.Bean manages to replace the damaged painting with a printedreproduction, saving the day. He not only escapes the disaster but alsohelps the curator’s family reconcile, forming a deep friendship with themuseum curator in the end.</p><p>I admire Rowan Atkinson because, despite his outstanding performance,he is incredibly intelligent. He studied at Oxford University and earneda Master`s degree in Electrical Engineering. Yet, he chose to perform asa clown, dedicating relentless effort to refine his role. The morepeople love Mr. Bean, the more it shows his hard work.</p><p>Another key point making him admirable is his generosity. RowanAtkinson is one of the highest donors to public welfare in the world,having donated over 300 million dollars, most of which went to Africa.This shows how much love is in his heart.</p><h3 id="开学第一天不寻常的一餐聚会上认识的人很开心认识的人喜欢买便宜货的人喜欢一起学习工作的人和别人一起做的事情和朋友去的有趣的地方穿最好的衫自然之地冒风险少人去的地方宜居之城他城的短暂停留居住地发展经常拍照的地方愉悦的公共交通之旅迟到有趣的老人一张照片昂贵地方嘈杂地空气糟糕之地想颁布的新法律投诉">开学第一天，不寻常的一餐，聚会上认识的人，很开心认识的人，喜欢买便宜货的人，喜欢一起学习/工作的人，和别人一起做的事情，和朋友去的有趣的地方，穿最好的衫，自然之地，冒风险，少人去的地方，宜居之城，他城的短暂停留，居住地发展,经常拍照的地方，愉悦的公共交通之旅，迟到，有趣的老人，一张照片，昂贵地方，嘈杂地，空气糟糕之地，想颁布的新法律，投诉</h3><p>Sure, I'd love to share about my first day on campus. It was on thefirst day of university when I met some friends I had previouslyconnected with online. We decided to have a special dinner at a uniquelocation—the Shimao Quarry Hotel, in Songjiang District of Shanghai.This place is extraordinary because it's located 80 meters below groundlevel, surrounded by massive aquarium-like glass walls with fish andother marine life swimming all around.</p><p>During this dinner, I was really happy to meet my new friend, whostood out with his medium height, slightly chubby build, and constantsmile. We attend the same university, but we do different subject, hemajors in Digital Media Arts while I am studying Computer Science.Despite that, we were surprised discovering we had almost identicalinterests, from painting to playing the guitar, and swimming. We chattedfor a long time and added each other's wechat and qq, two mainstreamsocial media applications in china like ins or facebook.</p><p>Kevin is a great companion and collaborator. Last June, when I wantedto join a game design competition but lack of help, he offered to joinmy team. I handled the coding with a few teammates, while he and otherstook charge of the art design, including characters, scenes and other UIelements. Fortunately, Our simple adventure game won first prize,bringing us closer. Whenever we had different opinions, we alwaysdiscussed and communicated effectively without any conflicts.</p><p>Since then, whenever there is a relevant competition, he is the firstperson up to my mind. From the mathematical modeling contest toapplication/website design competitions, we’ve always worked welltogether, producing exellent projects and winning awards. His outgoingpersonality and excellent communication skills, balanced with mycautious approach, make us a great team.</p><p>However, he is keen on buying goods with low price and has a technicof finding bargains. Most of his daily items, from clothes, toothbrushesto electronic equipments, are all bought online at the lowest pricesafter extensive comparison. Whenever we pass a one-dollar store or ahigh-discount shop, he can't help going in and isn't able to controlhimeself to buy something at a low price. Though the items he buys arecheap, their quality and appearance are not bad. He explained that heprefers not to spend too much on brand value or fashion looks, focusinginstead on the product's functions and cost performance. Of course, hemade exceptions on Valentine's Day just few days ago when his girlfrienddesired luxury gifts. necklace with little diamond</p><p>Last summer, we decided to travel together. After researching variouscities, we chose Weihai, a coastal city in Shandong. Despite Shanghaibeing coastal too, its nearby seas which are always filled with soil areyellow due to the sediment carried by the Yangtze River. We had alwayswanted to see a truly blue sea.</p><p>We arrived by train at night and had a quick dinner at a snack barbefore heading to our hotel. The next morning, I wore a light blueshirt, one of the most expensive clothes I own, which is a valuablebirthday gift from my mother. I wanted to wear my best outfit for myfirst time seeing the sea, and this shirt, though is touched thick, feltsilky and breathable, matching perfectly with the sea and sky thatday.</p><p>We took a double-decker sightseeing bus along the coastal road,enjoying the fantastic views of cliffs, endless sea, and crashing waves.The 30 km route connected multiple beaches, coastal parks, islands, andold buildings. The ride was smooth, allowing us to sit on the open-airupper deck, feeling the sea breeze on our faces.</p><p>On the bus, we met a tour group mainly composed of elderly people.One elderly man stood out, sitting in the row ahead of us. Unlike theothers in simple appearence, he wore a straw hat, tropical print shirtand colourful shorts, with a camera on his hand. He started aconversation with us, revealing he was from Sichuan, an inland province,and it was his first time seeing the sea. He had traveled to many otherplaces before and showed us his travel photos, from the icy northeast tothe tropical rainforests of Yunnan and climbing Changbai Mountain. Heeven gave us tips on photography such as shutter button...closeup... Hewas cheerful and talkative, who is seemed without any worries, which wastruly interesting.</p><p>Weihai felt like a fairytale town, with its blue sea at the end ofthe road, fresh city scenery, and the refreshing smell of sea salt inthe air. Surprisingly, it's also the closest coastal city in China toSouth Korea, with Korean food available everywhere. The sunset over thesea, with the warm orange painting on the water and waves, was verytouching. We took many valuable photos at sunset, each reminding me ofthat summer and our strong friendship.</p><p>The island cats, elderly men in slippers, and children playing withbubbles—all gave the place a warm, vivid feel, making me forget thehustle and bustle of Shanghai. Weihai, quiet and unassuming, with itslow cost of living and slow pace, would be an ideal place to retire.</p><p>This is my hometown. So, every holiday, I take my camera and travelfrom south to north, capturing its incredible scenery, which never failsto inspire me with new ideas.</p><p>When we arrived, we planned an 8 AM ferry ride to an island nearWeihai. Arriving at our hotel around 10 PM, we had a late dinner andthen started discussing on our travel plans, pushing our bedtime tonearly 1 AM. Consequently, we overslept until 9 AM. I suddenly woke upand jumped at the time I saw the watch, then I woke my friend, and werushed to the ferry terminal without brushing teeth or washing faces butonly to find our ferry had left, making our tickets invalid. Luckily, wewere able to catch the last morning ferry at 10:30, reaching the islandsuccessfully. This taught me to better manage my time for importantevents.</p><p>On the island, we hiked to a lighthouse. My friend spotted a rockyarea with small grey houses and another beach on the other side. He waseager to go over there to see what it was, but after looking around, wecouldn't find any path leading there, except for a rough rocky trailalong the edge of the cliff. On one side was the sea with sharp rocks,and on the other side was an almost vertical cliff wall. I could hardlyimagine what would happen if someone were to fall down. Despite theuneven, water-seeping rocks and the crashing waves nearby, he wasfearless, and I carefully followed. It felt like it only took about tenminutes, but for me, it seemed like an hour, and though I was sweating,we safely reached the golden beach. It was a hidden place, untouched bytourists and undeveloped by the goverment as well, unlike thecommercialized city center beaches. There were no shops or trash, justsand, shells, and waves.</p><p>In the evening, we visited a popular seafood market, bustling withstalls and restaurants. The crowded and noisy atmosphere wasn'tappealing to me, but Kevin wanted to try the seafood since he wasconvinced by the Internet social media. We picked a large restaurantthat looked impressive from the outside, but the oily tables andodd-smelling utensils like dishes and chopsticks were disappointing. Wechose a yellow fish and some clams, but the heavily seasoned disheslacked freshness. The bill shocked us—650 yuan for two dishes, with thefish alone costing 500 yuan, making it the most overpriced meal I’veever had.</p><p>Later, we walked to the market's end, where the air was filled withthe strong odd smell of rotten seafood and garbage. The area waslittered with waste from the nearby restaurants. We took photos andreported the issue to the local government service platform. To oursurprise, they responded within half a month, fining the responsiblerestaurants 10,000 yuan and ordering them to clean up. They alsoarranged regular inspections, sharing photos of the cleaned area withme. This was my first successful complaint, showing Weihai's commitmentto tourism and environmental protection.</p><p>At that moment, I thought of introducing a new law that requiresrestaurants to manage their own kitchen waste, with penalties of onemonth's revenue for illegal dumping.</p><p>Cleaner streets and markets will enhance the tourist experience andprotect local wildlife.The law is likely to be popular among residents,tourists, and governments. They will appreciate the cleaner environment,making visits and daily life more pleasant. Some restaurant owners mightinitially resist, but acceptance will grow as benefits becomeevident.</p><h3 id="家里最放松的地方学习之地喜欢做的日常事务收到想要物品-让你骄傲的事常用网站不喜欢的广告未来想学的学科">家里最放松的地方，学习之地，喜欢做的日常事务，收到想要物品,让你骄傲的事，常用网站，不喜欢的广告，未来想学的学科</h3><p>In my home, the most relaxing place for me is a wooden desk. It's asimple study desk that I bought about 10 years ago. The desk has a whitesurface with a green rubber mat on it. Behind it, there's a glassbookshelf, but instead of books, it's filled with various models. Thesemodels range from motorcycles and airplanes to robots and differentmodel scenes, all of which I've made by hand since I was in elementaryschool.</p><p>On the left wall, there are about a dozen tools hanging, such assandpaper, and paint. On the right side, there are piles of books andreference materials that I often use. I got interested in making modelsaround the age of 10 because my cousin showed me the models he made, andI was deeply fascinated. Since then, this desk has become my workspace.Whenever I feel anxious or sad, I sit by this plain desk and immersemyself in model making. It helps me calm down and forget all thenegative emotions. In the beginning, I faced many challenges, likesanding the edges and choosing the right paint, but these challengesdidn't make me give up. Instead, I constantly searched for informationin books and online, watching tutorials to overcome thesedifficulties.</p><p>In the middle of the shelf, there's a large robot model, a Gundammodel from Japan, about 30cm tall. It was a birthday gift from my fatherwhen I turned 16. I was very surprised because it was a model I hadwanted for a long time. About two years ago, I saw it at a modelexhibition. It had a blue and white color scheme, two pairs ofmechanical wings on its back, and it held two light weapons. The eyesand chest could even light up green, and I was completely appealed. Ishowed a photo to my father and vividly described its appearance andfeatures, but I didn't ask him to buy it because I knew it was expensiveand he didn't want me to be too absorbed in models, fearing it mightaffect my studies. However, on my birthday, he bought it for me, and Iwas so touched I almost cried. I spent a week assembling it and sprayeda protective paint on it, then placed it in the center of the bookshelf,covered with a glass case to protect it. Every time I see it, I can feelthe happiness and excitement from seven years ago.</p><p>Even if I don't have time to make models, I sit here every day,enjoying them, changing their poses, or repainting parts that have fadedover time. This has become my daily routine. These models have witnessedmy growth and represent the progress of my craftsmanship. Wheneverguests visit, their praise on these models make me feel proud.</p><p>When relatives and friends visit, some children show interest in mymodels. Of course, I don't let them touch the ones on the shelves sincethey are elaborate and could be damaged easily. Instead, I take outsimpler models for them to build. For example, when I was in highschool, my cousin came to visit. He was still in elementary school andshowed great interest in my models. So, I took out a tank model andshowed him the basic steps and how to use the tools. He excitedlystarted building, and I guided him along the way, ensuring he didn't gethurt. After more than an hour, he had built most of the tank, and I lethim take it home to finish. The next day, he sent me a photo of thecompleted model on WeChat. He was very happy, and it was clear that hehad a passion for model making and could focus on following theinstructions step by step. I was glad to pass on this love for modelmaking to him.</p><p>This desk is also my favorite place to study. Before going touniversity, I didn't stay at a boarding school, so every day afterschool, I would sit at this desk to rest and do my homework. This deskhas been with me for 11 years of my academic journey, and you can stillsee some pen marks on the surface. Although it looks ordinary, itsurpasses any modern desk in the library. Sitting at this desk alwaysbrings a sense of calm, allowing me to focus better on my studies.</p><p>One of the websites I frequently use is Bilibili, which is similar toYouTube and very popular among young people in China, especiallyanimation fans. A middle school classmate recommended it to me. WhileTikTok is known for short videos, Bilibili mainly features traditionallong videos on various topics, from science and fashion to almost allsubjects from elementary to university level. Each video has bulletcomments, where viewers' comments appear on the screen, creating ashared viewing experience. So, when exams are approaching, I watchrelevant courses on this site for revision. The bullet comments alsohelp solve difficult points. When I'm bored, I watch interesting oreducational videos to relax and share my favorite videos withfriends.</p><p>However, I occasionally come across annoying ads online, especiallyon some video or gaming websites. When I play online games or watchvideos, pop-up ads often appear in the lower right corner, showingpictures of models or scenes of fighting monsters with titles like "Makemoney playing poker" or "Make money playing games." But when you clickon them, you find it's actually online gambling, using exaggeratedamounts and slogans to attract people with weak self-control to investtheir money. They tempt people with small rewards to cheat more money.It seems like a fair game, but everything can be manipulated by theserver's backend. I don't mind shopping or commercial ads becausecompanies need profits, but these gambling ads that exploit people'sweaknesses to make dirty money are very unacceptable. Telecom fraudmakes many addicted people lose everything.</p><p>Therefore, I want to study cybersecurity in the future, eitherdomestically or abroad for graduate studies. Under the guidance ofprofessors, I want to strengthen my theoretical knowledge and enhancepractical applications through internships. However, it's a challengingfield because the internet is vast and complex, with various hackingtechniques constantly emerging. Cross-regional communication methods andvarious hiding techniques make tracking criminal IPs more difficult. Ihope to combine artificial intelligence and neural networks tostrengthen network defense and completely stop such behavior.</p><h3 id="别人给你做的特殊一餐">别人给你做的特殊一餐</h3><p>A special meal I remember was made by my grandmother. It was thefirst meal I had after coming home for summer vacation in 2022. For thepast two years, this wouldn't have been very special. But that year,Shanghai had a major COVID-19 outbreak, and we were in lockdown fromMarch to June. During those three months, I stayed at school, takingonline classes and eating terrible boxed meals, which made me feel quitedepressed.</p><p>So, after the lockdown ended and I returned home, my grandmotherpersonally cooked for me. She started preparing in the morning, going tothe local supermarket to pick fresh ingredients, ensuring thateverything was of the highest quality. She then spent several hours inthe kitchen, carefully cooking each dish with love and attention todetail. She made xiaolongbao, red cooked pork, and fried chicken becauseshe knew these were my favorites. Each dish was incredibly delicious,making me almost forget the awful boxed meals I had for the past threemonths.</p><p>I was deeply touched by the effort and care my grandmother put intomaking this meal. Each bite was filled with warmth and love, making itnot just a meal but a memorable experience.</p><h3 id="难用的科技产品想换掉的东西">难用的科技产品，想换掉的东西</h3><p>A piece of technology I find difficult to use is a robot vacuumcleaner that my dad bought quite a while ago. He got it with theintention of making household cleaning easier, especially for our busyfamily. The idea was that it would save us time and effort, keeping thefloors clean without much care.</p><p>However, I've found it challenging to operate. The first issue is thesetup; it required connecting to a smartphone app, which often hadconnectivity problems. Even after getting it set up, the robot wouldfrequently get stuck in corners or under furniture, requiring manualintervention to get it going again. The scheduling feature also didn'twork as smoothly as expected, often leading to the robot starting at oddhours or not starting at all.</p><p>Because of these issues, I don't use it as often as I thought Iwould. Instead, I usually end up sweeping the floors myself, which isfaster and less frustrating. While I appreciate the idea behind thetechnology, it feels more like a hassle than a help. This has made me abit skeptical about other "smart" home devices, as they might promiseconvenience but sometimes end up being more trouble than they'reworth.</p><h3 id="重要植物">重要植物</h3><p>A tree I find significant is the pine tree. The Pine tree is a talland evergreen type with slender trunks and needle-like leaves. They havean elegant look, with uniquely shaped branches.</p><p>I often see pine trees in parks and forests, especially in coolerclimates. Near my hometown, there's a forested area filled with pinetrees that I visit often. Their towering presence and the soft rustlingof their needles create a peaceful atmosphere.</p><p>China's most famous pine tree is the Guest-Greeting Pine on YellowMountain. It grows halfway up the mountain at about 1,600 meters high,with some even rooted on nearly vertical cliffs. Despite being exposedto wind and rain, these trees stand firmly and unyielding.</p><p>Pine trees are vital for their ecosystems, providing habitat and foodfor wildlife. They also hold cultural significance, symbolizinglongevity and persistence, especially in East Asian cultures.</p><p>Personally, I find pine trees inspiring for their ability to thrivein harsh conditions. They remind me of the importance of staying strongand enduring challenges, no matter how difficult they may be.</p><h3 id="历史建筑">历史建筑</h3><p>One historical building I visited is the Cologne Cathedral, locatedin Cologne, Germany. I had the opportunity to visit this iconic landmarkduring a study trip to Germany in my second year of high school, where Iwas part of a German language class.</p><p>The Cologne Cathedral is an impressive Gothic structure, known forits towering twin spires that reach towards the sky. The exterior isdecorated with complicated stone carvings and detailed sculptures,showing the art of the medieval craftsmen and architects. Inside, thecathedral is just as inspiring, with high ceilings, stunning colourfulglass windows, and a sense of magnificence that leaves a lastingimpression on anyone who visits.</p><p>Next to the cathedral, we saw some believers praying devoutly.Inside, the cathedral was dim, creating a solemn atmosphere that matchedexactly what I had imagined a grand cathedral to be like. Later, myclassmates and I climbed the spiral staircase step by step, reaching themiddle section of the cathedral. From there, we could look out and seethe entire cityscape of Cologne, which was truly breathtaking.</p><p>Despite the gand feel inside, what I saw outside included thesleeping cats, elderly men in slippers, and children playing withbubbles, which all gave the place a warm, vivid feel, making me forgetthe hustle and bustle of Shanghai.</p><p>Today, the Cologne Cathedral is still used as a place of religion,but it also attracts millions of tourists from around the world eachyear. It’s a World Heritage Site and an important symbol of Cologne’shistory and culture.</p><p>During my visit, I learned a great deal about the cathedral’shistory, including the fact that it took over 600 years to complete. Ialso gained an understanding of its significance in both religious andcultural contexts.</p><p>I was deeply moved by the large scale and beauty of the CologneCathedral. Standing in its presence, I felt a sense of respect for thehistory it represents and the countless generations of people whocontributed to its creation. The visit left me with a greaterappreciation for Gothic architecture and the enduring treasure of suchhistorical monuments.</p><h3 id="olympic-game">Olympic game</h3><ol type="1"><li><strong>Opening ceremony</strong> - 开幕式</li><li><strong>Gold medal</strong> - 金牌</li><li><strong>Silver medal</strong> - 银牌</li><li><strong>Bronze medal</strong> - 铜牌</li><li><strong>Host city</strong> - 主办城市</li><li><strong>Athlete</strong> - 运动员</li><li><strong>Swimming events</strong> - 游泳比赛</li><li>Pan Zhanle surpassed all other competitors in the men's 100mfreestyle of swimming, breaking the world record with a time of 46.4seconds and winning the gold medal.</li></ol>]]></content>
    
    
    <categories>
      
      <category>IELTS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IELTS</tag>
      
      <tag>speaking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp_note</title>
    <link href="/2024/06/30/cpp-note/"/>
    <url>/2024/06/30/cpp-note/</url>
    
    <content type="html"><![CDATA[<h3 id="string">String</h3><ul><li>string = vector<char></char></li><li><strong>vector的函数string都可以用</strong></li></ul><h4 id="字符串字符数组的输入输出">字符串（字符数组）的输入输出</h4><ol type="1"><li><code>cin</code>遇到space/enter结束</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> line[<span class="hljs-number">10</span>];<br>cin &gt;&gt; line;  <span class="hljs-comment">//输入 &quot;123 456&quot;</span><br>cout &lt;&lt; line &lt;&lt; endl;  <span class="hljs-comment">//只能输出 &quot;123&quot;</span><br><br><span class="hljs-comment">//string同理</span><br>string s;<br>cin &gt;&gt; s;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>getchar()</code></li></ol><ul><li>读取一个字符</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> num;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; num) &#123;<br>nums.push_back(num);<br><span class="hljs-comment">// 读到换行符，终止循环</span><br><span class="hljs-keyword">if</span>(getchar() == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>getline(cin, str)</code></li></ol><ul><li><p>读取一行，且输入结束后丢弃最后的换行符</p></li><li><p>头文件<code>&lt;string&gt;</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-comment">// 输出读入的字符串</span><br>cout &lt;&lt; s &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><h4 id="获取字符串长度">获取字符串长度</h4><ul><li><code>sizeof()</code></li></ul><p>得到指针占用的字节数 = 4</p><ul><li><code>strlen(char* s)</code></li></ul><p>在计算字符数组(char str[ ])时，一般用strlen()函数</p><ul><li><code>s.size() / length()</code></li></ul><p>计算字符串（string）长度，不能用char*作为参数。</p><p>除此之外，size()函数还可以获取vector类型的长度。</p><h4 id="裁切">裁切</h4><p><code>s.substr(int pos, int len)</code></p><h4 id="转int">转int</h4><p><code>stoi(str)</code></p><p>把string转为int</p><h4 id="拼接">拼接</h4><p><code>append</code>&amp;<code>+</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">s1.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;def&quot;</span>);<br><span class="hljs-comment">//or</span><br>s2 += s3;<br></code></pre></td></tr></table></figure><h4 id="替换">替换</h4><p><code>replace(pos,len,str)</code></p><h4 id="判断数字字母">判断数字/字母</h4><p><code>isdigit(c)</code></p><p><code>isalpha(c)</code></p><h4 id="查找子串">查找子串</h4><p><code>char *strstr(const char *haystack, const char *needle)</code></p><p>返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回null</p><h4 id="获取末尾字符">获取末尾字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> b=a.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><h3 id="数学函数math.h">数学函数<code>&lt;math.h&gt;</code></h3><h4 id="乘方">乘方</h4><p><code>double pow(double x, double y)</code>: x<sup>y</sup></p><h3 id="标准库limits.h">标准库<code>&lt;limits.h&gt;</code></h3><h4 id="maxmin">max/min</h4><table><thead><tr class="header"><th>CHAR_MAX</th><th>char最大值</th></tr></thead><tbody><tr class="odd"><td>INT_MAX</td><td></td></tr><tr class="even"><td>LLONG_MAX</td><td></td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td>CHAR_MIN</td><td>char最小值</td></tr><tr class="odd"><td>INT_MIN</td><td></td></tr><tr class="even"><td>LLONG_MIN</td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;char: &quot;</span>&lt;&lt; CHAR_MAX &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="常用方法algorithm.h">常用方法<code>&lt;algorithm.h&gt;</code></h3><h4 id="翻转">翻转</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(a, a+n);<span class="hljs-comment">//n为数组中的元素个数</span><br><span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//string</span><br></code></pre></td></tr></table></figure><h4 id="排序">排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//默认升序</span><br><br><span class="hljs-comment">//自定义排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x &gt; y; <span class="hljs-comment">//降序</span><br>&#125;<br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>(),cmp_max); <br></code></pre></td></tr></table></figure><h3 id="链表">链表</h3><ul><li>必须自定义构造函数，默认构造函数无法赋值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 单链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    ListNode(<span class="hljs-type">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><table style="width:100%;"><thead><tr class="header"><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="even"><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="odd"><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table style="width:100%;"><thead><tr class="header"><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="odd"><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h4 id="集合set">集合set</h4><ul><li><p><strong>构造函数</strong>：创建一个空的<code>unordered_set</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br></code></pre></td></tr></table></figure></li><li><p><strong>插入元素</strong>：使用 <code>insert()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>查找元素</strong>：使用 <code>find()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> it = uset.<span class="hljs-built_in">find</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (it != uset.<span class="hljs-built_in">end</span>()) &#123;<br>  <span class="hljs-comment">// 元素存在</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong>：使用 <code>erase()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">erase</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>大小和空检查</strong>：使用 <code>size()</code> 和<code>empty()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> size = uset.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">bool</span> isEmpty = uset.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>清空容器</strong>：使用 <code>clear()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure></li></ul><h4 id="字典map">字典map</h4><ul><li><p>包含头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>声明 map 容器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;key_type, value_type&gt; myMap;<br><br>std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>key_type</code> 是键的类型。</li><li><code>value_type</code> 是值的类型。</li></ul></li><li><p>插入元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">myMap[key] = value;<br></code></pre></td></tr></table></figure></li><li><p>访问元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">value = myMap[key];<br></code></pre></td></tr></table></figure></li><li><p>遍历map:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;std::string, <span class="hljs-type">int</span>&gt; employees;<br><span class="hljs-comment">// 遍历 map 并打印员工信息</span><br><span class="hljs-keyword">for</span> (std::map&lt;std::string, <span class="hljs-type">int</span>&gt;::iterator it = employees.<span class="hljs-built_in">begin</span>(); it != employees.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">&quot; years old.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查找键<code>find</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 查找键为2的元素</span><br><span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong>：使用 <code>erase()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">umap.<span class="hljs-built_in">erase</span>(key);<br></code></pre></td></tr></table></figure></li><li><p><strong>大小</strong>：使用 <code>size()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> size = umap.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>清空容器</strong>：使用 <code>clear()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">umap.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure></li></ul><h5 id="map自定义排序">map自定义排序</h5><ul><li><p>map-value排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//map value排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;string,<span class="hljs-type">int</span>&gt;&amp; a,<span class="hljs-type">const</span> pair&lt;string,<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.second==b.second)<span class="hljs-keyword">return</span> a.first&lt;b.first;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.second&gt;b.second;<br>&#125;<br>map&lt;string,<span class="hljs-type">int</span>&gt; m&#123;&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>&#125;&#125;;<br><br>vector&lt;pair&lt;string,<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(m.<span class="hljs-built_in">begin</span>(),m.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//将map中的元素拷贝到vector中</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),compare);<span class="hljs-comment">//实现value的排序</span><br></code></pre></td></tr></table></figure></li><li><p>map-key排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//自定义map的key排列顺序</span><br>map&lt;string,<span class="hljs-type">int</span>,greater&lt;string&gt;&gt; m1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myCompare</span> &#123;<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; l, <span class="hljs-type">const</span> string&amp; r)</span><span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>  <span class="hljs-keyword">return</span> l.<span class="hljs-built_in">length</span>() &gt; r.<span class="hljs-built_in">length</span>();<br> &#125;<br>&#125;;<br>map&lt;string,<span class="hljs-type">int</span>,myCompare&gt; m2;<br><br></code></pre></td></tr></table></figure></li><li><p>注意：在class内定义cmp函数需要加static</p><p><a href="https://blog.csdn.net/weixin_40710708/article/details/111269356">错误解决方法：error:reference to non-static member function must becalled-CSDN博客</a></p></li></ul><h3 id="堆栈队列">堆、栈、队列</h3><h4 id="栈">栈</h4><p><code>#include&lt;stack&gt;</code></p><ul><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;Type&gt; s;<br></code></pre></td></tr></table></figure></li><li><p><code>push()</code>: 在栈顶添加一个元素。</p></li><li><p><code>pop()</code>: 移除栈顶元素。</p></li><li><p><code>top()</code>: 返回栈顶元素的引用，但不移除它。</p></li><li><p><code>empty()</code>: 检查栈是否为空。</p></li><li><p><code>size()</code>: 返回栈中元素的数量。</p></li></ul><h4 id="队列">队列</h4><p><code>#include &lt;queue&gt;</code></p><ul><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;Type&gt; q;<br></code></pre></td></tr></table></figure></li><li><p><code>empty()</code>: 检查队列是否为空。</p></li><li><p><code>size()</code>: 返回队列中的元素数量。</p></li><li><p><code>front()</code>: 返回队首元素的引用。</p></li><li><p><code>back()</code>: 返回队尾元素的引用。</p></li><li><p><code>push()</code>: 在队尾添加一个元素。</p></li><li><p><code>pop()</code>: 移除队首元素。</p></li></ul><h4 id="双端队列">双端队列</h4><p><code>&lt;deque&gt;</code></p><ul><li><p>```c++ std::deque<int> dq; <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> <span class="hljs-code">`push_back()`</span>：在队列尾部添加元素。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`push_front()`</span>：在队列头部添加元素。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`pop_back()`</span>：移除队列尾部的元素。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`pop_front()`</span>：移除队列头部的元素。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`empty()`</span>: 检查队列是否为空。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`size()`</span>: 返回队列中的元素数量。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`front()`</span>: 返回队首元素的引用。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`back()`</span>: 返回队尾元素的引用。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`clear()`</span>：移除所有元素，使 deque 为空。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`erase(pos)`</span>：移除指定位置的元素。<br><br><br><br><span class="hljs-section">#### 优先队列 (堆)</span><br><br><span class="hljs-code">`priority_queue&lt; type, container, function&gt;`</span><br><br><span class="hljs-bullet">+</span> 初始化<br><br>  <span class="hljs-code">```c++</span><br><span class="hljs-code">   std::priority_queue&lt;int&gt; pq; </span><br></code></pre></td></tr></table></figure></int></p></li><li><p><code>empty()</code>: 检查队列是否为空。</p></li><li><p><code>size()</code>: 返回队列中的元素数量。</p></li><li><p><code>top()</code>: 返回队列顶部的元素（不删除它）。</p></li><li><p><code>push()</code>: 向队列添加一个元素。</p></li><li><p><code>pop()</code>: 移除队列顶部的元素。</p></li></ul><h5 id="自定义优先级">自定义优先级</h5><p><strong>默认最大堆</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span> &#123;<span class="hljs-comment">// 也可以class compare&#123; public: ...&#125;</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b; <span class="hljs-comment">// 定义最小堆</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 创建一个自定义类型的优先队列，使用最小堆</span><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, compare&gt; pq_min;<br><br><span class="hljs-comment">// or</span><br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; small_heap;<br></code></pre></td></tr></table></figure><h3 id="vector">vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="初始化">初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; myVector; <span class="hljs-comment">// 空 vector</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myVector</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个包含 5 个整数的 vector，每个值都为默认值（0）</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myVector</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 创建一个包含 5 个整数的 vector，每个值都为 10</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// 初始化一个包含元素的 vector</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(v.begin()+<span class="hljs-number">1</span>, v.end()<span class="hljs-number">-1</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="扩容缩容">扩容/缩容</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector.<span class="hljs-built_in">resize</span> (<span class="hljs-number">5</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//初始化容量5和初值0</span><br></code></pre></td></tr></table></figure><h4 id="添加插入元素">添加/插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 将整数 7 添加到 vector 的末尾</span><br><br><span class="hljs-comment">//插入</span><br><span class="hljs-keyword">auto</span> it1 = a.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-keyword">auto</span> it2 = a.<span class="hljs-built_in">insert</span>((it1+<span class="hljs-number">1</span>), &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="访问元素">访问元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = myVector[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取第一个元素</span><br><span class="hljs-type">int</span> y = myVector.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取第二个元素</span><br><span class="hljs-type">int</span> p = myVector.<span class="hljs-built_in">back</span>()<span class="hljs-comment">//最后一个元素</span><br></code></pre></td></tr></table></figure><h4 id="获取元素个数">获取元素个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size = myVector.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取 vector 中的元素数量</span><br></code></pre></td></tr></table></figure><h4 id="迭代">迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myVector.<span class="hljs-built_in">begin</span>(); it != myVector.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : myVector) &#123;<br>    std::cout &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除">删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除第三个元素</span><br><span class="hljs-type">int</span> p = myVector.<span class="hljs-built_in">pop_back</span>() <span class="hljs-comment">// 移除末尾</span><br>myVector.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空 vector</span><br></code></pre></td></tr></table></figure><h3 id="list-双向链表">list 双向链表</h3><blockquote><p>不需要在创建时指定大小，并且可以在任何位置添加或删除元素，而不需要重新分配内存。相比vector，插入或删除元素更快</p></blockquote><ul><li><p>头文件：<code>#include &lt;list&gt;</code></p></li><li><p>声明列表：<code>std::list&lt;T&gt; mylist;</code></p></li><li><p>插入元素：</p><ul><li><code>mylist.push_back(value);</code></li><li>`<code>push_front()</code></li></ul></li><li><p>删除元素：</p><ul><li><code>pop_back();</code></li><li>`<code>pop_front()</code></li><li><code>erase(iterator);</code></li></ul></li><li><p>访问元素：不支持随机访问</p><ul><li><code>mylist.front();</code></li><li><code>mylist.back();</code></li></ul></li><li><p>遍历列表：使用迭代器</p><ul><li><code>for (auto it = mylist.begin(); it != mylist.end(); ++it)</code></li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">begin</span>()<span class="hljs-comment">// 返回指向容器中第一个元素的双向迭代器。</span><br><span class="hljs-built_in">end</span>()<span class="hljs-comment">// 返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器。</span><br><span class="hljs-built_in">rbegin</span>()<span class="hljs-comment">// 返回指向最后一个元素的反向双向迭代器。</span><br><span class="hljs-built_in">rend</span>()<span class="hljs-comment">// 返回指向第一个元素所在位置前一个位置的反向双向迭代器。</span><br></code></pre></td></tr></table></figure></p></li><li><p>容器容量</p><ul><li><code>size()</code></li></ul></li></ul><h3 id="pair">pair</h3><p><code>#include &lt;utility&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">pair&lt;T1, T2&gt; p1;            <br><span class="hljs-function">pair&lt;T1, T2&gt; <span class="hljs-title">p1</span><span class="hljs-params">(v1, v2)</span></span>;   <br><br>p1 &lt; p2;   <span class="hljs-comment">// 依次比较first,second</span><br>p1 == p2；   <br>    <br>p1.first;                   <br>p1.second;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programing language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c_note</title>
    <link href="/2024/06/30/c-note/"/>
    <url>/2024/06/30/c-note/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串">字符串</h3><h4 id="字符串字符数组的输入输出">字符串（字符数组）的输入输出</h4><ol type="1"><li><p><code>gets()</code>遇到enter结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> <span class="hljs-comment">//gets() 、puts()需string.h</span></span><br><span class="hljs-type">char</span> ch1[<span class="hljs-number">20</span>];<span class="hljs-comment">//字符数组</span><br>gets(ch1);<br><span class="hljs-built_in">puts</span>(ch1);<br></code></pre></td></tr></table></figure></li><li><p><code>scanf()</code>遇到space/enter结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> ch2[<span class="hljs-number">20</span>];<span class="hljs-comment">//字符数组</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ch2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,ch2);<br>fflush(<span class="hljs-built_in">stdin</span>);<span class="hljs-comment">//清除缓冲区(或者使用getchar()去除enter)</span><br></code></pre></td></tr></table></figure></li><li><p><code>getchar()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> ch;<br><span class="hljs-type">char</span> a[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>((ch=getchar())!=<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-comment">//一直接收缓冲区的字符。直至收到回车</span><br>&#123;<br>    a[i]=ch;<br>    i++;<br>&#125;<br>a[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;    <span class="hljs-comment">//加上串尾符</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="获取字符串长度">获取字符串长度</h4><ul><li><p>sizeof()</p><p>得到指针占用的字节数 = 4</p></li><li><p>strlen(char* s)</p><p>在计算字符数组(char str[ ])时，一般用strlen()函数</p></li><li><p>size()/length()</p><p>计算字符串（string）长度，不能用char*作为参数。</p><p>除此之外，size()函数还可以获取vector类型的长度。</p></li></ul><h3 id="printf格式输出">printf格式输出</h3><h4 id="规定符">规定符</h4><ul><li><p><strong>%d</strong> 十进制有符号整数</p></li><li><p><strong>%u</strong> 十进制无符号整数</p></li><li><p><strong>%f</strong> 浮点数</p></li><li><p><strong>%s</strong> 字符串</p></li><li><p><strong>%c</strong> 单个字符</p></li><li><p><strong>%p</strong> 指针的值</p></li><li><p><strong>%e</strong> 指数形式的浮点数</p></li><li><p><strong>%x, %X</strong> 无符号以十六进制表示的整数</p></li><li><p><strong>%o</strong> 无符号以八进制表示的整数</p></li><li><p><strong>%lu</strong> 32位无符号整数</p></li><li><p><strong>%llu</strong> 64位无符号整数</p></li><li><p><strong>%%</strong> 输出百分号字符本身</p></li></ul><h4 id="其他选项">其他选项</h4><ul><li>%-10s：左对齐并占用宽度为 10 的字符串</li><li>%5.2f：右对齐并占用宽度为 5，保留两位小数的浮点数</li><li>%#x：输出带有 0x 前缀的十六进制数</li></ul><h4 id="数据类型占用字节数">数据类型占用字节数</h4><figure><img src="/2024/06/30/c-note/c-note\image-20240704103625855.png" alt="image-20240704103625855"><figcaption aria-hidden="true">image-20240704103625855</figcaption></figure><h3 id="文件读写">文件读写</h3><h4 id="打开文件">打开文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode )</span>;<br></code></pre></td></tr></table></figure><p><strong>filename</strong> 是字符串，用来命名文件，访问模式<strong>mode</strong> 的值可以是下列值中的一个：</p><table><thead><tr class="header"><th style="text-align: left;">模式</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">r</td><td style="text-align: left;">打开一个已有的文本文件，允许读取文件。</td></tr><tr class="even"><td style="text-align: left;">w</td><td style="text-align: left;">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr class="odd"><td style="text-align: left;">a</td><td style="text-align: left;">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr class="even"><td style="text-align: left;">r+</td><td style="text-align: left;">打开一个文本文件，允许读写文件。</td></tr><tr class="odd"><td style="text-align: left;">w+</td><td style="text-align: left;">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr class="even"><td style="text-align: left;">a+</td><td style="text-align: left;">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;rb&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;rb+&quot;</span>, <span class="hljs-string">&quot;r+b&quot;</span>, <span class="hljs-string">&quot;wb+&quot;</span>, <span class="hljs-string">&quot;w+b&quot;</span>, <span class="hljs-string">&quot;ab+&quot;</span>, <span class="hljs-string">&quot;a+b&quot;</span><br></code></pre></td></tr></table></figure><h4 id="关闭文件">关闭文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">( FILE *fp )</span>;<br></code></pre></td></tr></table></figure><p>如果成功关闭文件，<strong>fclose( )</strong>函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong></p><h4 id="写入文件">写入文件</h4><h5 id="char">char</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">( <span class="hljs-type">int</span> c, FILE *fp )</span>;<br></code></pre></td></tr></table></figure><h5 id="string">string</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *fp )</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *fp,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span><br></code></pre></td></tr></table></figure><p>返回值：</p><ul><li>success =&gt;写入的字符</li><li>fail =&gt; EOF</li></ul><h5 id="example">example</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   FILE *fp = <span class="hljs-literal">NULL</span>;<br> <br>   fp = fopen(<span class="hljs-string">&quot;/tmp/test.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>   <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;This is testing for fprintf...\n&quot;</span>);<br>   <span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;This is testing for fputs...\n&quot;</span>, fp);<br>   fclose(fp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读取文件">读取文件</h4><h5 id="char-1">char</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">( FILE * fp )</span>;<br></code></pre></td></tr></table></figure><p>返回值：char转换的int</p><p><strong>输出时，使用<code>printf("%c", c)</code>进行类型转换</strong></p><h5 id="string-1">string</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">( <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> n, FILE *fp )</span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>fgets()</code> 从 fp 所指向的输入流中读取 n - 1个字符。它会把读取的字符串复制到缓冲区<strong>buf</strong>，并在最后追加一个 <strong>null</strong>字符来终止字符串</p></li><li><p>停止读取：换行符 '' 或文件的末尾 EOF</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span> <br></code></pre></td></tr></table></figure><ul><li>停止读取：换行符 '' 或空格</li></ul><h5 id="example-1">example</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buff[<span class="hljs-number">255</span>];<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s&quot;</span>, buff);<br>fgets(buff, <span class="hljs-number">255</span>, (FILE*)fp);<br></code></pre></td></tr></table></figure><h3 id="数学函数math.h">数学函数<code>&lt;math.h&gt;</code></h3><h4 id="pow">pow</h4><p><code>double pow(double x, double y)</code>: x<sup>y</sup></p><h3 id="标准库stdlib.h">标准库<code>&lt;stdlib.h&gt;</code></h3><h4 id="free">free</h4><p>void free(void *ptr)</p><h4 id="malloc">malloc</h4><p>void *malloc(size_t size)</p><h4 id="abs">abs</h4><p>int abs(int x)</p><h4 id="fmax">fmax</h4><p>double fmax(double x, double y);</p><h4 id="fmin">fmin</h4><p>double fmin(double x, double y);</p><h4 id="qsort">qsort</h4><p><code>void qsort(void base, size_t nitems, size_t size, int (compar)(const void *, const void *));</code></p><h5 id="参数">参数</h5><ul><li><p><code>base</code>: 指向待排序数组的第一个元素的指针。</p></li><li><p><code>nitems</code>: 数组中的元素数量。</p></li><li><p><code>size</code>:数组中每个元素的大小（以字节为单位）。</p></li><li><p>``` compar <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  : 比较函数的指针，该函数用于比较两个元素。比较函数应当返回一个整数，表示比较结果：<br><br>  - 小于零：表示第一个元素小于第二个元素。<br>  - 等于零：表示两个元素相等。<br>  - 大于零：表示第一个元素大于第二个元素。<br><br>```<span class="hljs-function">c</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">cmp</span> (<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * b</span>)</span><br>&#123;<br>   <span class="hljs-keyword">return</span> ( *(<span class="hljs-built_in">int</span>*)a - *(<span class="hljs-built_in">int</span>*)b );<br>&#125;<br>qsort(values, <span class="hljs-number">5</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>), cmp);<br><br><span class="hljs-meta"># struct 排序</span><br><span class="hljs-keyword">struct</span> node&#123;<br><span class="hljs-built_in">int</span> i;<br><span class="hljs-built_in">double</span> j;<br><span class="hljs-built_in">char</span> k;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">cmp</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *a,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *b</span>)</span> &#123;<br><span class="hljs-keyword">return</span> (*(node*)a).i-(*(node*)b).i;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h3 id="标准库limits.h">标准库<code>&lt;limits.h&gt;</code></h3><table><thead><tr class="header"><th><code>INT_MIN</code></th><th><code>int</code> 类型的最小值</th><th>-2147483648</th></tr></thead><tbody><tr class="odd"><td><code>INT_MAX</code></td><td><code>int</code> 类型的最大值</td><td>2147483647</td></tr><tr class="even"><td><code>UINT_MAX</code></td><td><code>unsigned int</code> 类型的最大值</td><td>4294967295</td></tr></tbody></table><h3 id="常用方法algorithm.h">常用方法<code>&lt;algorithm.h&gt;</code></h3><ul><li><p><strong>reverse</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">reverse</span>(a, a+n);<span class="hljs-comment">//n为数组中的元素个数</span><br><span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//string</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="链表">链表</h3><ul><li>必须自定义构造函数，默认构造函数无法赋值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 单链表</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    ListNode(<span class="hljs-type">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><table style="width:100%;"><thead><tr class="header"><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="even"><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="odd"><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><table style="width:100%;"><thead><tr class="header"><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="odd"><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h4 id="set">set</h4><ul><li><p><strong>构造函数</strong>：创建一个空的<code>unordered_set</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<br></code></pre></td></tr></table></figure></li><li><p><strong>插入元素</strong>：使用 <code>insert()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>查找元素</strong>：使用 <code>find()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> it = uset.<span class="hljs-built_in">find</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (it != uset.<span class="hljs-built_in">end</span>()) &#123;<br>  <span class="hljs-comment">// 元素存在</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong>：使用 <code>erase()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">erase</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>大小和空检查</strong>：使用 <code>size()</code> 和<code>empty()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> size = uset.<span class="hljs-built_in">size</span>();<br><span class="hljs-type">bool</span> isEmpty = uset.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>清空容器</strong>：使用 <code>clear()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">uset.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure></li></ul><h4 id="map">map</h4><ul><li><p>包含头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>声明 map 容器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;key_type, value_type&gt; myMap;<br><br>std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>key_type</code> 是键的类型。</li><li><code>value_type</code> 是值的类型。</li></ul></li><li><p>插入元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">myMap[key] = value;<br></code></pre></td></tr></table></figure></li><li><p>访问元素:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">value = myMap[key];<br></code></pre></td></tr></table></figure></li><li><p>遍历map:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map&lt;std::string, <span class="hljs-type">int</span>&gt; employees;<br><span class="hljs-comment">// 遍历 map 并打印员工信息</span><br><span class="hljs-keyword">for</span> (std::map&lt;std::string, <span class="hljs-type">int</span>&gt;::iterator it = employees.<span class="hljs-built_in">begin</span>(); it != employees.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">&quot; years old.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查找键<code>find</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 查找键为2的元素</span><br><span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong>：使用 <code>erase()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">umap.<span class="hljs-built_in">erase</span>(key);<br></code></pre></td></tr></table></figure></li><li><p><strong>大小</strong>：使用 <code>size()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> size = umap.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>清空容器</strong>：使用 <code>clear()</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">umap.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure></li></ul><h4 id="section"></h4><h3 id="堆栈队列">堆、栈、队列</h3><h3 id="priority_queue">priority_queue</h3><ul><li><p>初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; 默认最大堆<br></code></pre></td></tr></table></figure></li><li><p><code>empty()</code>: 检查队列是否为空。</p></li><li><p><code>size()</code>: 返回队列中的元素数量。</p></li><li><p><code>top()</code>: 返回队列顶部的元素（不删除它）。</p></li><li><p><code>push()</code>: 向队列添加一个元素。</p></li><li><p><code>pop()</code>: 移除队列顶部的元素。</p></li></ul><h5 id="自定义优先级">自定义优先级</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b; <span class="hljs-comment">// 定义最小堆</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 创建一个自定义类型的优先队列，使用最小堆</span><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, compare&gt; pq_min;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>programing language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_note</title>
    <link href="/2024/06/30/python-note/"/>
    <url>/2024/06/30/python-note/</url>
    
    <content type="html"><![CDATA[<h3 id="global全局-nonlocal嵌套函数">global（全局）nonlocal(嵌套函数)</h3><h3 id="io">IO</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 循环读取到文件末尾</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        s = <span class="hljs-built_in">input</span>()<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 读取n,m，再读取n个数，m行</span><br>n, m = (<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>))<br>a = [<span class="hljs-built_in">int</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    s = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-comment"># 读取的第二种方法，map映射</span><br>a1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br><span class="hljs-comment"># 输出n个数在一行（无行尾空格）</span><br>ans = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> ans[:-<span class="hljs-number">1</span>]:<br>    <span class="hljs-built_in">print</span>(j, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(ans[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h3 id="自定义排序">自定义排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">nums.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])<br><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key<br>nums.sort(key=cmp_to_key(<span class="hljs-keyword">lambda</span> x,y:x-y)<br></code></pre></td></tr></table></figure><p>对于cmp(this,other),如果返回为负值，则将<strong>this元素排列到输出列表前面</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> a + b &gt;= b + a:<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>arr = <span class="hljs-built_in">sorted</span>(arr, key=cmp_to_key(cmp), reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="enumerate">enumerate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lst)<br></code></pre></td></tr></table></figure><h3 id="排列组合">排列组合</h3><h4 id="全组合">全组合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations<br>a = <span class="hljs-string">&#x27;abc&#x27;</span>   <span class="hljs-comment">#对字符串进行combinations排列组合</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> combinations(a,<span class="hljs-number">2</span>):<br>    x = <span class="hljs-string">&#x27;&#x27;</span>.join(i)<br>    <span class="hljs-built_in">print</span> (x,end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><p>output:<code>ab ac bc</code></p><h4 id="全排列">全排列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>result=itertools.permutations(a,<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(result)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;itertools.permutations&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(result)<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><h3 id="解包">解包</h3><p>*list 去除括号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(*list1)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="string">String</h3><h3 id="format">format</h3><ul><li><p><code>&#123;a:.2f&#125;</code> 保留a小数点后两位</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python3">&gt;&gt;&gt; f&quot;&#123;a:8.1f&#125;&quot;<br>&#x27;   123.5&#x27;<br></code></pre></td></tr></table></figure></li><li><p><code>&#123;a:&lt;10d&#125;</code> 左对齐 (宽度为10)</p></li><li><p><code>&#123;a:0&gt;2d&#125;</code> 数字右对齐，并补零 (宽度为2) e.g. 5-&gt; 05</p></li></ul><h3 id="进制">进制</h3><p>b:二进制；o:八进制；d:十进制；x:十六进制</p><h4 id="其他进制转十进制">其他进制转十进制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span>（‘<span class="hljs-number">302</span>’, [<span class="hljs-number">2</span>/<span class="hljs-number">8</span>/<span class="hljs-number">16</span>]）<br></code></pre></td></tr></table></figure><h4 id="十进制转其他进制">十进制转其他进制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bin</span>(),<span class="hljs-built_in">oct</span>(),<span class="hljs-built_in">hex</span>()<br></code></pre></td></tr></table></figure><h3 id="双向队列">双向队列</h3><h4 id="collections.dequeiterablemaxlen">collections.deque([<em>iterable</em>[,<em>maxlen</em>]])</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">d = deque(<span class="hljs-string">&#x27;python&#x27;</span>)    <span class="hljs-comment">#生成一个新的deque</span><br><br>d.append(<span class="hljs-string">&#x27;r&#x27;</span>)          <span class="hljs-comment">#右边新增一值</span><br>d.appendleft(<span class="hljs-string">&#x27;l&#x27;</span>)      <span class="hljs-comment">#左边新增一值，list不存在此方法</span><br>d.extend(iterable)<span class="hljs-comment">#右边新增可迭代对象</span><br>d.extendleft<br>d.insert(index,<span class="hljs-string">&#x27;m&#x27;</span>)<br><br>d.pop()                <span class="hljs-comment">#删掉并返回最右边值</span><br>d.popleft()            <span class="hljs-comment">#删掉并返回最左边值</span><br><br><span class="hljs-built_in">print</span>(d.count(<span class="hljs-string">&#x27;p&#x27;</span>))    <span class="hljs-comment">#count计数方法，返回次数</span><br><span class="hljs-built_in">print</span>(d.index(<span class="hljs-string">&#x27;y&#x27;</span>))    <span class="hljs-comment">#index定位操作，返回位置</span><br><br>d.reverse<br>d.clear<br></code></pre></td></tr></table></figure><p><strong>但deque不支持切片slice操作</strong></p><h3 id="计数器">计数器</h3><h4 id="collections.counter">collections.counter</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br>list1 = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>]<br>dic = Counter(list1)<br><span class="hljs-built_in">print</span>(dic)<br><span class="hljs-comment">#结果:次数是从高到低的</span><br><span class="hljs-comment">#Counter(&#123;&#x27;a&#x27;: 3, &#x27;g&#x27;: 3, &#x27;c&#x27;: 2, &#x27;f&#x27;: 2, &#x27;b&#x27;: 1&#125;)</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>(dic))<br><span class="hljs-comment">#结果:按字母顺序排序的</span><br><span class="hljs-comment">#&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 1, &#x27;c&#x27;: 2, &#x27;f&#x27;: 2, &#x27;g&#x27;: 3&#125;</span><br><br><span class="hljs-built_in">print</span>(dic.items()) <span class="hljs-comment">#dic.items()获取字典的key和value</span><br><span class="hljs-comment">#结果:按字母顺序排序的</span><br><span class="hljs-comment">#dict_items([(&#x27;a&#x27;, 3), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 2), (&#x27;f&#x27;, 2), (&#x27;g&#x27;, 3)])</span><br><br><span class="hljs-built_in">print</span>(dic.keys())<br><span class="hljs-comment">#结果:</span><br><span class="hljs-comment">#dict_keys([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;f&#x27;, &#x27;g&#x27;])</span><br><br><span class="hljs-built_in">print</span>(dic.values())<br><span class="hljs-comment">#结果：</span><br><span class="hljs-comment">#dict_values([3, 1, 2, 2, 3])</span><br></code></pre></td></tr></table></figure><h3 id="最大公约数">最大公约数</h3><h4 id="math.gcdintegers">math.gcd(*integers)</h4><h3 id="最小公倍数">最小公倍数</h3><h4 id="math.lcmintegers">math.lcm(*integers)</h4><h3 id="n">n!</h3><h4 id="math.factorialn">math.factorial(n)</h4><h3 id="二分-bisect">二分 bisect</h3><ul><li><p><strong>前提：列表有序</strong></p></li><li><p>使用 bisect 模块的方法之前，须确保待操作对象是<strong>有序序列</strong></p></li></ul><p><code>bisect.bisect_left(array, x, [lo=0, hi=len(a)])</code></p><ul><li>找出插在最靠近x之前的位置，lo/hi上下限</li></ul><h3 id="heapq最小堆">heapq最小堆</h3><p><code>import heapq</code></p><ol type="1"><li><p>创建堆</p><ul><li>a=[]</li><li>a=heapify(x) :<strong>一个列表转化为小根堆</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappush(a,<span class="hljs-number">18</span>)<br>heappop(a)<br></code></pre></td></tr></table></figure></li><li><p>nlargest(n , iterbale, key=None) / nsmallest(n , iterbale,key=None)</p><p>获取列表中最大、最小的几个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>]<br>heapq.nlargest(<span class="hljs-number">5</span>,a)<br><span class="hljs-comment"># [25, 20, 15, 10, 8]</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="数论">数论</h3><ol type="1"><li><p>质数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br>primes = [<span class="hljs-number">1</span>]*n<br>primes[<span class="hljs-number">0</span>]=primes[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">int</span>(n**<span class="hljs-number">0.5</span>)+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span> primes[i]:<br>        primes[i*i:n:i]=[<span class="hljs-number">0</span>]*((n-i*i-<span class="hljs-number">1</span>)//i+<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(primes))<br></code></pre></td></tr></table></figure></li><li><p>扩展欧几里得</p><ul><li><strong>ax+by=gcd(a,b)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">exgcd</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, a<br>    x, y, g = exgcd(b, a % b)<br>    x, y = y, x - a // b * y<br>    <span class="hljs-keyword">return</span> x, y, g<br></code></pre></td></tr></table></figure></li></ol><figure><img src="/2024/06/30/python-note/image-20240410204638912.png" alt="image-20240410204638912"><figcaption aria-hidden="true">image-20240410204638912</figcaption></figure><h3 id="快速幂">快速幂</h3><p>pow（a,b,z）= a^b%z</p><h3 id="idle-settings">IDLE settings</h3><ul><li><p>*Python</p></li><li><p>打开目录下的config-extensions.def文件</p></li><li><p>[AutoComplete] enable=1 popupwait=0</p></li><li><p>找到 <code>AutoComplete.py</code></p></li><li><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;Complete either attribute names or file names.</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">Either on demand or after a user-selected delay after a key character,</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">pop up a list of candidates.</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> string</span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span></code></pre></div></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>programing language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo publish article</title>
    <link href="/2024/06/30/hexo-publish-article/"/>
    <url>/2024/06/30/hexo-publish-article/</url>
    
    <content type="html"><![CDATA[<h2 id="how-to-create-a-new-article-and-publish-it-to-hexo-blog">How tocreate a new article and publish it to hexo blog?</h2><h3 id="生成文章">生成文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &lt;title&gt;<br></code></pre></td></tr></table></figure><p>执行该命令，Hexo会在<code>/source/_posts</code>目录下创建一篇新的文章:</p><ul><li>文章开头配置项：</li></ul><table><thead><tr class="header"><th style="text-align: left;">配置项</th><th style="text-align: left;">意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">title</td><td style="text-align: left;">网页文章标题</td></tr><tr class="even"><td style="text-align: left;">date</td><td style="text-align: left;">文章创建如期</td></tr><tr class="odd"><td style="text-align: left;">comments</td><td style="text-align: left;">文章评论功能是否启动</td></tr><tr class="even"><td style="text-align: left;">tags</td><td style="text-align: left;">文章标签</td></tr><tr class="odd"><td style="text-align: left;">categories</td><td style="text-align: left;">文章分类</td></tr><tr class="even"><td style="text-align: left;">keywords</td><td style="text-align: left;">文章关键字</td></tr></tbody></table><h3 id="发布文章">发布文章</h3><ol type="1"><li>清除缓存</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>生成预览</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g #生成<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo s #本地预览，http://localhost:4000/<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>上传</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d #上传到github<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Base 2 Review</title>
    <link href="/2024/05/27/Data-Base-2-Review/"/>
    <url>/2024/05/27/Data-Base-2-Review/</url>
    
    <content type="html"><![CDATA[<h3 id="五规范化设计">五、规范化设计</h3><h4 id="函数依赖">函数依赖</h4><ol type="1"><li><p>数据库的规范化设计理论：数据依赖、范式、模式设计</p><ul><li><p>核心作用：数据依赖</p></li><li><p>设计标准：范式</p></li></ul></li><li><p>泛关系模式存在的问题：</p><ul><li>数据冗余</li><li>修改/插入/删除异常</li></ul></li></ol><h4 id="nf2nf3nfbcnf">1NF,2NF,3NF,BCNF</h4><h4 id="无损分解">无损分解</h4><ol type="1"><li><p>模式设计方法原则</p><p>表达性、分离性、最小冗余性</p></li></ol><h3 id="七数据库设计">七、数据库设计</h3><h4 id="规划">规划</h4><ul><li>输出：可行性分析报告+数据库系统规划纲要</li></ul><h4 id="需求分析">需求分析</h4><ul><li>输入：信息需求+处理需求</li><li>输出：需求说明书</li><li>步骤：<ol type="1"><li>分析用户活动，产生用户活动图（业务流程）</li><li>确定系统范围，产生系统范围图（人机界面）</li><li>分析用户活动所涉及的数据，产生数据流图DFD</li><li>分析系统数据，产生数据字典DD</li></ol></li></ul><h4 id="概念设计">概念设计</h4><ul><li>输入：DFD</li><li>输出：分ER图 -&gt; 总ER图</li><li>步骤：<ol type="1"><li>进行数据抽象,设计局部概念模式</li><li>将局部概念模式综合成全局概念模式</li><li>评审</li></ol></li></ul><h4 id="逻辑设计">逻辑设计</h4><ul><li>输入：<ul><li>独立于DBMS的概念模式</li><li>处理需求</li><li>约束条件</li><li>DBMS特性</li></ul></li><li>输出：<ul><li>DBMS可处理的模式</li><li>子模式</li><li>应用程序设计指南</li><li>物理设计指南</li></ul></li><li>步骤：<ol type="1"><li>形成初始模式：ER 实体类型/联系类型 -&gt; 记录类型</li><li>子模式设计：应用程序和数据库系统的<strong>接口</strong></li><li>应用程序设计梗概：设计应用程序草图</li><li>模式评价：<ul><li>定量分析</li><li>性能测量</li></ul></li><li>修正模式：使模式适应信息的不同表示</li></ol></li><li>ER-&gt;关系模型转换规则<ul><li>1:1<ul><li><strong>可以在</strong>任意一关系模式属性中加入另一方的键和联系属性</li></ul></li><li>1:N<ul><li>N端加入1端的键和联系属性</li></ul></li><li>M:N<ul><li>联系类型转换成关系</li><li>属性为两端实体的键</li></ul></li><li>弱实体 1:N(弱实体)<ul><li>1端键作为外键加入弱实体</li><li>弱实体主键由父表主键和自身候选键组成</li></ul></li></ul></li></ul><h4 id="物理设计">物理设计</h4><ul><li>输入：基本数据模型</li><li>输出：物理结构</li><li>步骤：<ol type="1"><li>存储记录结构设计</li><li>确定数据存放位置</li><li>存取方法的设计</li><li>完整性和安全性考虑</li><li>程序设计</li></ol></li></ul><h4 id="实现">实现</h4><h4 id="运行和维护">运行和维护</h4><h3 id="八数据库的管理">八、数据库的管理</h3><h4 id="事务acid">事务ACID</h4><h4 id="数据库恢复">数据库恢复</h4><ol type="1"><li>恢复方法: 转储和建立日志</li><li>故障:<ul><li>事务故障</li><li>系统故障</li><li>介质故障</li></ul></li></ol><h4 id="数据库并发两种锁活死锁可串行化">数据库并发（两种锁，活死锁，可串行化）</h4><ol type="1"><li>并发操作的三个问题：<ul><li>丢失更新</li><li>读脏数据</li><li>不一致分析</li></ul></li></ol><h4 id="数据库完整性3静态1动态">数据库完整性（3静态，1动态）</h4><ol type="1"><li><p>完整性：正确性、有效性、相容性</p></li><li><p>完整性约束：</p><ul><li><p>域约束</p></li><li><p>基本表约束</p><p><code>FOREIGN KEY (..) REFERENCES TABLE(..)</code></p></li><li><p>断言</p></li><li><p>触发器：</p><ul><li>元组级触发器：<code>for each row</code></li><li>语句级触发器</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TRIGGER</span>  TRI_UPD_SC               <span class="hljs-comment">/*触发器的命名*/</span><br>  INSTEAD  <span class="hljs-keyword">OF</span>  <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">OF</span> CNO  <span class="hljs-keyword">ON</span>  SC     <span class="hljs-comment">/*时间、事件、目标*/</span><br>  <span class="hljs-keyword">REFERENCING</span>                             <span class="hljs-comment">/*设置变量*/</span>   <br>    OLD_TABLE  <span class="hljs-keyword">AS</span>  OLDSTUFF         <span class="hljs-comment">/*为语句级触发器设置变量*/</span><br>    NEW_TABLE  <span class="hljs-keyword">AS</span>  NEWSTUFF<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br> <span class="hljs-keyword">WHEN</span> （<span class="hljs-number">50</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-keyword">ALL</span>（<span class="hljs-keyword">SELECT</span>  <span class="hljs-built_in">COUNT</span>(SNO)    <span class="hljs-comment">/*动作时间条件*/</span><br>    <span class="hljs-keyword">FROM</span> ((SC <span class="hljs-keyword">EXCEPT</span> OLDSTUFF) <span class="hljs-keyword">UNION</span> NEWSTUFF)<br>    <span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span>  CNO）））<br>  <span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">ATOMIC</span>                                 <span class="hljs-comment">/*动作体*/</span><br>    <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span>  SC                            <span class="hljs-comment">/*触发动作1*/</span><br>    <span class="hljs-keyword">WHERE</span> (SNO,CNO,GRADE) <span class="hljs-keyword">IN</span> OLDSTUFF; <br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SC                             <span class="hljs-comment">/*触发动作2*/</span><br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> NEWSTUFF<br>  <span class="hljs-keyword">END</span>;<br><br></code></pre></td></tr></table></figure><h4 id="数据库安全">数据库安全</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">UPDATE</span>(PRICE) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">TO</span> WANG [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br><br><span class="hljs-keyword">REVOKE</span> .. <span class="hljs-keyword">ON</span> .. <span class="hljs-keyword">FROM</span> .. [CASCADE<span class="hljs-operator">|</span>RESTRICT]<br></code></pre></td></tr></table></figure><h3 id="九分布式数据库系统">九、分布式数据库系统</h3><h4 id="物理上分散逻辑上集中">物理上分散，逻辑上集中</h4><ol type="1"><li>数据独立性：逻辑独立性+物理独立性</li><li>分类：<ul><li>同构同质型</li><li>同构异质型：DBMS型号不同</li><li>异构型</li></ul></li></ol><h4 id="数据分片">数据分片</h4><ul><li>水平分片</li><li>垂直分片</li><li>导出分片（导出水平分片）：水平分片的条件不是本关系属性的条件，而是其他关系属性的条件</li><li>混合分配，三种混合</li></ul><p>三条规则：</p><ul><li>完备性</li><li>可重构</li><li>不相交</li></ul><h4 id="数据分配">数据分配</h4><ul><li>集中式</li><li>分割式：数据一份，分割成的每个逻辑片段被指派到特定场地</li><li>全复制式：数据在每个场地重复存储</li><li>混合式：介于分割式和全复制式。每个子集安置在一个或多个场地</li></ul><p>全局关系、逻辑片段、场地（物理映像）</p><h3 id="十对象数据库系统">十、对象数据库系统</h3><h4 id="对象联系图">对象联系图</h4><ul><li>平面关系模型：基本数据类型</li><li>嵌套关系模型：基本数据类型、关系类型（集合）</li><li>复合对象模型：基本数据类型、关系类型、结构类型（元组类型）</li><li>面向对象：基本类型、复合类型、引用类型</li></ul><figure><img src="/2024/05/27/Data-Base-2-Review/image-20240527132513389.png" alt="image-20240527132513389"><figcaption aria-hidden="true">image-20240527132513389</figcaption></figure><ol type="1"><li><p>用ORDB的定义语言，定义这个数据库:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span>  TYPE  MyString  <span class="hljs-type">char</span>  <span class="hljs-type">varying</span>；<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TABLE</span>  department(university  MyString,<br>dname  MyString, <br>staff  setof(<span class="hljs-keyword">ref</span>(faculty)), <br>dire <span class="hljs-keyword">ref</span>(director));<br><br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">TABLE</span>  faculty(fno  <span class="hljs-type">integer</span>,fname MyString,  <br>languages  setof(MyString),<br>countries  setof(MyString),<br>works_for  <span class="hljs-keyword">ref</span>(department));<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> director(dno  <span class="hljs-type">integer</span>) Under  faculty;<br></code></pre></td></tr></table></figure></li><li><p>检索精通俄语（Russian）的教师工号和姓名。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  fno, fname<br><span class="hljs-keyword">FROM</span>  faculty<br><span class="hljs-keyword">WHERE</span>  ‘Russian’  <span class="hljs-keyword">in</span>  languages;<br></code></pre></td></tr></table></figure></p></li><li><p>检索上海地区各大学超过50岁的教师人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  A.uname，count（<span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span>  A.staff <span class="hljs-keyword">as</span> B<br><span class="hljs-keyword">WHERE</span>  B.age＞<span class="hljs-number">50</span>）<br><span class="hljs-keyword">FROM</span>  university  <span class="hljs-keyword">as</span> A<br><span class="hljs-keyword">WHERE</span>  A.city <span class="hljs-operator">=</span> ˊshanghaiˊ； <br></code></pre></td></tr></table></figure></li></ol><h3 id="tips">tips</h3><ol type="1"><li>关系模式n个属性，可能的函数依赖4<sup>n</sup>个，平凡的函数依赖3<sup>n</sup>个，正确的调度n！个</li><li>B的函数依赖要写B-&gt; Φ, B-&gt;B</li><li>候选码为全码的关系模式一定是满足BCNF</li></ol>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>database2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer System Architecture Review</title>
    <link href="/2024/05/17/Computer-System-Architecture-Review/"/>
    <url>/2024/05/17/Computer-System-Architecture-Review/</url>
    
    <content type="html"><![CDATA[<h2 id="一导论">一、导论</h2><h4 id="计算机系统结构3说法">计算机系统结构3说法</h4><ul><li>五大部件：运算器、控制器、存储器、输入输出设备</li><li>软件和硬件组成</li><li>由人员、数据、设备、持续和规程组成</li></ul><h4 id="冯诺伊曼结构">冯诺伊曼结构</h4><ul><li><p>特点：存储程序、运算器为中心、集中控制</p><p>①存储器是按地址访问的顺序线性编址的一维结构，每个单元的位数是固定的</p><p>②指令由操作码和地址码组成</p><p>③指令在存储器中是按其执行顺序存储的，由程序计数器指明每条指令所在单元的地址。</p><p>④在存储器中指令和数据被同等对待</p><p>⑤计算机系统结构以运算器、控制器为中心</p><p>⑥指令、数据均以二进制编码表示，采用二进制运算。</p></li><li><p>现代计算机对冯的改进：</p><ul><li>不变：存储程序</li><li>改变：存储器为中心，总线结构，分散控制</li></ul></li></ul><h4 id="计算机系统层次结构">计算机系统层次结构</h4><ul><li>虚拟计算机：由软件实现的机器。从不同角度所看到的计算机系统属性是不同的。</li></ul><h4 id="系统结构2种定义">系统结构2种定义</h4><ol type="1"><li><p>从程序设计者所看到的计算机属性，即概念性结构和功能特性</p></li><li><p>研究软硬件功能分配和对软硬件界面的确定</p></li></ol><h4 id="计算机组成与实现">计算机组成与实现</h4><ol type="1"><li>计算机组成：计算机系统结构的逻辑实现</li><li>计算机实现：计算机组成的物理实现</li></ol><h4 id="模拟和仿真">模拟和仿真</h4><p>在某一系统结构上实现另一种系统结构</p><ul><li>模拟：用机器语言程序解释实现程序移植的方法</li><li>仿真：微程序直接解释另一种机器的指令系统</li></ul><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515123824104.png" alt="image-20240515123824104"><figcaption aria-hidden="true">image-20240515123824104</figcaption></figure><h4 id="加速比">加速比</h4><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515124114407.png" alt="image-20240515124114407"><figcaption aria-hidden="true">image-20240515124114407</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515124151554.png" alt="image-20240515124151554"><figcaption aria-hidden="true">image-20240515124151554</figcaption></figure><h4 id="计算机系统结构分类flynn分类">计算机系统结构分类（Flynn分类）</h4><ul><li>SISD:单指令流单数据流 -&gt; 串行计算机</li><li>SIMD:单指令流多数据流 -&gt; 并行处理机</li><li>MISD:多指令流单数据流 -&gt; 无食用价值</li><li>MIMD:多指令流多数据流 -&gt; 多处理机和多计算机</li><li>SPMD:单程序多数据流 -&gt; MIMD的一个子类，基于Cluster</li><li>SIMT:单指令多线程 -&gt; Nvidia 公司提出，GPU</li></ul><h2 id="二处理器">二、处理器</h2><h4 id="cisc-risc">CISC &amp; RISC</h4><ul><li>复杂指令系统CISC<ul><li>提供复杂指令来提高性能</li><li>所含指令至少300条，甚至超过500条</li><li>设计目的：用最少的机器语言指令来完成所需的计算任务</li><li>使得硬件越来越复杂，<strong>造价相应提高</strong>，复杂的指令系统不但不容易实现，<strong>还可能降低性能</strong></li></ul></li><li>精简指令系统RISC<ul><li>只保留使用频率很高的少量指令</li><li>其他复杂功能通过组合指令（子程序）实现</li><li>提供一些必要的指令以支持OS和高级语言</li></ul></li></ul><h4 id="openmp">OpenMP</h4><ul><li><p>执行模型采用Fork-Join形式和共享内存模型</p></li><li><p>是任务级线程，不是SIMD</p></li><li><p><code>#pragma omp &lt;directive&gt;[clause [[,]clause]…]</code></p></li><li><p>常用的功能指令如下：</p><ul><li><p><code>parallel</code>：用在一个结构块之前，表示这段代码将被多个线程并行执行。</p></li><li><p><code>parallel for</code>：parallel和for指令的结合，也用于for循环语句之前，表示for循环体的代码将被多个线程并行执行，同时具有并行域的产生和任务分配两个功能。</p></li><li><p><code>reduction</code>：执行指定的归约运算。</p></li><li><p><code>single</code>：用在并行域内，表示一段只被单个线程执行的代码。</p></li><li><p><code>critical</code>：用在一段代码临界区之前，保证每次只有一个OpenMP线程进入。</p></li><li><p><code>barrier</code>：用于并行域内代码的线程同步，线程执行到barrier时要停下等待，直到所有线程都执行到barrier时才继续往下执行。</p></li></ul></li><li><p>example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;omp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OMP_THREADS 4 <span class="hljs-comment">// CPU OpenMP 线程数</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> LINE_FOR_CPU_THREADS = (N + OMP_THREADS - <span class="hljs-number">1</span>) / OMP_THREADS; <span class="hljs-comment">// 定义每个CPU线程计算的行数</span><br><span class="hljs-type">int</span> A[N][N]; <span class="hljs-comment">// 定义数组A</span><br><span class="hljs-type">int</span> i, j; <span class="hljs-comment">// 随机初始化数组A，每行从下标1开始，第0个元素用于记录该行最大值</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>                         A[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; N; j++)&#123;<br>A[i][j] = <span class="hljs-built_in">rand</span>()%<span class="hljs-number">10</span>;  &#125;  &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for num_threads(OMP_THREADS) <span class="hljs-comment">// 启动多线程计算</span></span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; OMP_THREADS; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ThreadIdx: %d\n&quot;</span>, i);<br>        <span class="hljs-type">int</span> k, lineID, sum;<br>        <span class="hljs-type">int</span> line_for_cpu_idx = LINE_FOR_CPU_THREADS * i;<span class="hljs-comment">// 计算该线程的起始计算行号</span><br>        <span class="hljs-keyword">for</span> (lineID = line_for_cpu_idx; lineID &lt; line_for_cpu_idx + LINE_FOR_CPU_THREADS; lineID++) &#123;<br>            <span class="hljs-keyword">if</span> (lineID &gt;= <span class="hljs-number">0</span> &amp;&amp; lineID &lt; N) &#123;<br>                sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; N; k++) &#123;<br>                    sum += A[lineID][k];<br>                &#125;<br>                A[lineID][<span class="hljs-number">0</span>] = sum;  &#125;  &#125;  &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123; <span class="hljs-comment">// 回到主线程，输出计算结果</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, A[i][j]);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  &#125; <br>    &#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="cuda">CUDA</h4><h5 id="gpu">GPU</h5><ul><li>专门面对高并发的计算任务（核：小+多）</li><li>基本的运算单元被称为流处理器（SP）。</li><li>多个流处理器、寄存器、缓存和指令控制单元组成 流多处理器（SM）。</li><li>SM是GPU执行指令的基本单位，在同一SM内的SP具有共享的高速一级缓存。整个GPU则是由多组SM、共享二级缓存以及显存控制器等组成。</li></ul><h5 id="cuda编程">CUDA编程</h5><ul><li>CUDA编程基于<strong>SIMD编程模型</strong>。执行核函数之前，用户需要（手动）将数据通过PCI-E通道由内存复制到显存中；核函数执行完毕后，用户再将运算后的数据由显存复制回主机的内存中。</li><li>GPU上执行的代码称为<strong>核函数</strong>（kernel）</li></ul><h5 id="cuda线程的组织">CUDA线程的组织：</h5><ul><li><p><strong>线程</strong>（Thread）：CUDA程序的基本执行单元。每个线程内的指令都会顺序执行。遵循SIMD编程模型，所有的线程都会执行相同的代码或相同代码的不同分支。理论上，所有的线程都是并行执行的，没有先后之分。</p></li><li><p><strong>线程块</strong>（Block）：由一组线程组成。每个线程块内部线程之间可以进行协作，有可以共同访问的共享内存。</p><p>CUDA程序执行时，每个线程块会在GPU上同一个SM中执行，每个线程块内的线程又会以线程束(Wrap)为单位，分组在SM中执行。线程束是GPU在执行时调度的最小单位。大小一般为32。</p></li><li><p><strong>网格</strong>（Grid）：一组线程块的集合。网格里的线程块会被调度到GPU的多个SM上去执行。线程块之间没有同步机制，执行的先后顺序不确定。</p></li></ul><h5 id="cuda核函数">CUDA核函数</h5><ul><li><p>GPU端运行的代码，规定GPU的各个线程访问哪些数据执行什么计算</p></li><li><p>每个核函数对应一个Grid，一个Grid中有一个或多个block,一个block中有一个或多个thread</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515140439833.png" alt="image-20240515140439833"><figcaption aria-hidden="true">image-20240515140439833</figcaption></figure></li></ul><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515140528216.png" alt="image-20240515140528216"><figcaption aria-hidden="true">image-20240515140528216</figcaption></figure><ul><li><p><code>kernel&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(param list)</code></p><p><code>Dg</code>：int型或者dim3类型(x,y,z)，定义一个<strong>Grid</strong>中<strong>Block</strong>是如何组织的，如果是int型，则表示一维组织结构</p><p><code>Db</code>：int型或者dim3类型(x,y,z)，定义一个<strong>Block</strong>中<strong>Thread</strong>是如何组织的，如果是int型，则表示一维组织结构</p><p><code>Ns</code>：size_t类型，可缺省，默认为0；用于设置每个block除了静态分配的共享内存外，最多能动态分配的共享内存大小，单位为byte。0表示不需要动态分配。S：cudaStream_t类型，可缺省，默认为0。表示该核函数位于哪个流。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)</span>, <span class="hljs-title">block</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)</span></span>; <br>kernel_name&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...);<br><span class="hljs-comment">//表示一个Grid中有3x2x1=6个Block，在(x,y,z)三个方向上的排布方式分别是3、2、1；</span><br><span class="hljs-comment">//一个Block中有4x3x1=12个Thread，在(x,y,z)三个方向上的排布方式分别是4、3、1。</span><br></code></pre></td></tr></table></figure></li><li><p>内置变量</p><ul><li><p>blockIdx：索引到线程块</p></li><li><p>threadIdx：索引到某个块内的线程</p></li><li><p>blockDim：得到一个块内线程总数</p></li><li><p>gridDim：得到一个格内块总数</p></li></ul><p>n在一维的情况下，计算线程全局id公式为</p><ul><li><strong>线程全局id = blockIdex.x * blockDim.x +threadIdx.x</strong></li></ul><p>n在一维的情况下，核函数内的线程总数为</p><ul><li><strong>核函数的线程总数 = gridDim.x * blockDim.x</strong></li></ul></li></ul><h2 id="三存储系统">三、存储系统</h2><h4 id="访问周期和命中率">访问周期和命中率</h4><p><span class="math inline">\(\begin{aligned}&amp;T=HT_1+(1-H)T_2\\&amp;\text{当命中率}H\to1\text{时,}T\toT_1\end{aligned}\)</span></p><p>T1：M1存储器的访问周期</p><p>T2：M2存储器的访问周期</p><h4 id="并行存储器">并行存储器</h4><h5 id="高位交叉">高位交叉</h5><ol type="1"><li><p>目的：扩大存储容量</p></li><li><p>实现方法：用地址码的高位部分区分存储体号</p></li><li><p>特点：</p><ul><li>具备并行工作的条件：每个存储模块有各自独立的控制部件，包括地址寄存器、地址译码器等，可以独立工作</li><li>编址的连续性：由于程序的连续性和局部性，大部分情况下，指令序列和数据分布在同一个存储模块中。只有当指令序列跨越两个存储模块时，才能并行工作</li><li><strong>扩大容量，未提高速度</strong></li></ul></li></ol><figure><img src="/2024/05/17/Computer-System-Architecture-Review/20180112210025854.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h5 id="低位交叉多体交叉编址">低位交叉(多体交叉编址)</h5><ol type="1"><li>目的：提高存储器访问速度</li><li>实现方法：用地址码的低位部分区分存储体号</li><li>虽然多体并行主存系统和单体并行主存系统最大频宽可以相同，但多体地址可以灵活设置，只要是在不同分体中，就能得到比单体更高的频宽。因为程序常有转移出现，使得实际访问地址不一定均匀分布在交叉分体上，致使效率下降。统计表明，采用多体并行主存结构的计算机系统获得的实际频宽约是最大理想频宽的1/3。</li><li>特点：<ul><li>存储体的访问周期T<sub>m</sub>，由<em>n</em>个存储体构成的主存储器，各存储体的启动间隔$t=T_m/n$</li><li>低位交叉存储器是一种采用<strong>分时工作</strong>工作的并行存储系统。在连续工作的情况下，保持每个存储体速度不变，则整个存储器速度可望提高<em>n</em>倍</li></ul></li></ol><figure><img src="/2024/05/17/Computer-System-Architecture-Review/20180112210047400.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515150131191.png" alt="image-20240515150131191"><figcaption aria-hidden="true">image-20240515150131191</figcaption></figure><ul><li>存储器的速度不随存储体个数的增加而线性提高，即n个存储体组成的存储器的加速比通常小于n。原因在于访问冲突：取指令时可能发生程序转移，取操作数时存在数据离散性</li></ul><h4 id="堆栈型替换算法">堆栈型替换算法</h4><ul><li><p>基本特点：</p><p>随着分配给程序的主存页面数增加，主存的命中率也提高，至少不下降</p></li><li><p>FIFO不是堆栈型算法，LRU,LFU,OPT是堆栈型</p></li></ul><h4 id="提高主存命中率方法">提高主存命中率方法</h4><h5 id="影响命中率的因素">影响命中率的因素</h5><ol type="1"><li>页面替换算法</li><li>页面大小<ul><li>页面大小为某个值时，命中率最大</li><li>随页面大小增大，主存页面数减少，页面替换更频繁</li></ul></li><li>主存储器容量<ul><li>命中率随主存容量的增加而单调上升，但是梯度逐渐变小</li><li>对于堆栈型：容量增大，页面数增加，命中率提高</li><li>非堆栈：不一定单调上升，但总趋势上升</li></ul></li></ol><h4 id="cache一致性问题">Cache一致性问题</h4><ol type="1"><li><p>造成Cache与主存不一致的原因：</p><ul><li>CPU写Cache，但没有立即写主存</li><li>IO处理机或IO设备写主存，但没有写Cache</li></ul></li><li><p>Cache的更新算法</p><ul><li>写直达法，WT(Write-through)</li></ul><p>​ CPU的数据写入Cache时，同时也写入主存</p><ul><li>写回法，WB (Write-Back)</li></ul><p>​CPU的数据只写入Cache，不写入主存，仅当替换时，才把修改过的Cache块写回主存</p><p>​Cache块表中为每一块设置一个修改位，初值为0。当块中任何一个字被修改时，修改位被置为1。</p></li></ol><h4 id="cache性能计算">Cache性能计算</h4><ol type="1"><li>平均存储器访问时间 = 命中时间 + 不命中率 * 不命中代价</li><li>CPU时间 = IC * (CPI + 不命中率 * 存储器存取次数/指令数 * 不命中代价)* T</li></ol><h4 id="cache命中率相关因素">Cache命中率相关因素</h4><ol type="1"><li><p>Cache的命中率随它的容量的增加而提高</p></li><li><p>组相联映像方式的Cache中，Cache容量一定时，块的大小对命中率的影响非常敏感</p><ul><li><p>块很小时，命中率H很低</p></li><li><p>随着块大小的增加，程序的空间局部性起作用，同一块中的数据的利用率提高，块命中率H提高</p></li><li><p>达到最大值以后，命中率H随块大小的增加反而减少。当块非常大时，程序的局部性减弱</p></li></ul></li><li><p>Cache命中率与组数的关系</p><p>在组相联映像的Cache中：</p><ul><li><p>随着组数的增加， Cache的命中率降低</p></li><li><p>当组数不太大时(512组以下)，命中率降低得相当少</p></li><li><p>当组数超过一定数量时，命中率下降非常快</p></li></ul></li><li><p><strong>相联度（每组块数）不是越大，命中率越高</strong></p></li></ol><h4 id="虚拟存储器的工作方式特点">虚拟存储器的工作方式、特点</h4><p>虚拟存储器是指“主存-辅存”层次，它能使该层次具有辅存容量、接近主存的等效速度和辅存的每位成本，使程序员可以按比主存大得多的虚拟存储空间编写程序（即按虚存空间编址）</p><p>Cache的主要作用是弥补主存和CPU之间的速度差距，因此它的管理部件是用硬件实现的，并对程序员透明。</p><p>但虚拟存储器的主要作用是弥补主存和辅存之间的容量差距，因此它的管理部件基本上靠软件，适当结合硬件来实现，对系统程序员也不是透明的。</p><h2 id="四流水线">四、流水线</h2><h4 id="先行控制">先行控制</h4><ul><li><p>使分析和执行部件分别连续不断地运行，使部件空闲状态减至最低</p></li><li><p>采用技术:</p><ul><li><p>缓冲技术</p></li><li><p>预处理技术</p></li></ul></li><li><p>先行控制与重叠区别：分析和执行部件可同时处理两条不相邻指令</p></li></ul><h4 id="流水技术特点">流水技术特点</h4><ol type="1"><li>可以划分为若干互有联系的子过程（功能段）。每个功能段由专用功能部件实现。</li><li>实现功能段所需的时间应尽可能相等，避免因不等产生处理瓶颈，造成“断流”。</li><li>形成流水线处理，需要一段准备时间，称为“通过时间”。只有在此之后流水过程才能稳定。</li><li>指令流不能顺序执行时，会使流水过程中断；再形成流水过程，则需经过一段时间。不应经常“断流”，否则效率不高。</li><li>流水线技术适用于大量重复的程序过程，只有输入端能连续提供服务，流水线效率才能够得到充分发挥。</li></ol><h4 id="流水线时空图">流水线时空图</h4><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515211925332.png" alt="image-20240515211925332"><figcaption aria-hidden="true">image-20240515211925332</figcaption></figure><h4 id="流水线性能指标">流水线性能指标</h4><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240515212453231.png" alt="image-20240515212453231"><figcaption aria-hidden="true">image-20240515212453231</figcaption></figure><h5 id="吞吐率">1. 吞吐率</h5><ul><li><p>单位时间内流水线能够处理的任务数</p></li><li><p><span class="math inline">\(\mathrm{TP}=\frac{n}{T}=\frac{n}{m\times\Deltat_{0}+(n-1)\times\Delta t_{0}}=\frac{1}{\Deltat_{0}\times\left(1+\frac{m-1}{n}\right)}=\frac{\mathrm{TP}_{\max}}{1+\frac{m-1}{n}}\)</span></p></li></ul><p>​ 若各段时间不相等：</p><ul><li><span class="math inline">\(\mathrm{TP}=\frac n{\sum_{i=1}^m\Deltat_i+(n-1)\Delta t_j}\)</span>， t<sub>j</sub>为最长的一段时间</li></ul><h5 id="加速比-1">2. 加速比</h5><ul><li><p>m段流水线的速度与等效的非流水线的速度之比称为加速比</p></li><li><p><span class="math inline">\(S=\frac{T_\text{非流水}}{T_\text{流水}}=\frac{mn\Deltat_0}{m\Delta t_0+(n-1)\Delta t_0}=\frac{mn}{m+n-1}=\fracm{1+\frac{m-1}n}\)</span></p></li></ul><p>​ 若各段时间不相等：</p><ul><li><span class="math inline">\(S=\frac{n\sum_{i=1}^m\Deltat_i}{\sum_{i=1}^m\Delta t_i+(n-1)\Delta t_j}\)</span></li></ul><h5 id="效率">3. 效率</h5><ul><li><p>工作时间的时空区与流水线中各段总的时空区之比</p></li><li><p><span class="math inline">\(E=\frac{nm\Delta t}{m(m+n-1)\Deltat}=\frac n{m+n-1}=\frac{S_p}m=T_p\Delta t\)</span></p><p>若各段时间不相等：</p></li><li><p><span class="math inline">\(E=\frac{n\sum_{i=1}^m\Deltat_i}{m\biggl[\sum_{i=1}^m\Delta t_i+(n-1)\Deltat_j\biggr]}=\frac{n\text{ 个任务占用的时空区}}{m\text{个段总的时空区}}\)</span></p></li></ul><h4 id="非线性流水线调度">非线性流水线调度</h4><ul><li><p>因功能段使用冲突，调度相对复杂</p></li><li><p>预约表</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516075824819.png" alt="image-20240516075824819"><figcaption aria-hidden="true">image-20240516075824819</figcaption></figure></li><li><p>禁止向量</p><p>F=（8，6，5，1）</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516075840659.png" alt="image-20240516075840659"><figcaption aria-hidden="true">image-20240516075840659</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516075850163.png" alt="image-20240516075850163"><figcaption aria-hidden="true">image-20240516075850163</figcaption></figure></li><li><p>冲突向量</p><p>C0 =（10110001）</p></li><li><p>状态转换图</p><ol type="1"><li><p>C0每过一拍逻辑右移一位，若移出0，则允许后续指令进入流水线，再与C0按位“或”，形成新的冲突向量Ci；（根据禁止表F的允许等待时间，本例：2，3，4，7,就是C0中0的位置）</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516075945667.png" alt="image-20240516075945667"><figcaption aria-hidden="true">image-20240516075945667</figcaption></figure></li><li><p>冲突向量C0经过移位后和后续指令（该指令仍然具备冲突向量C0特征)求或,得出新的冲突向量Ci</p></li></ol><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516084027838.png" alt="image-20240516084027838"><figcaption aria-hidden="true">image-20240516084027838</figcaption></figure><ol start="3" type="1"><li><p>重复上一步骤，直到不再生成新的冲突向量为止。（特例：如果有个状态是全1，11111111。则需要隔9隔周期，即所有状态前加0，按011111111处理）</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516084147421.png" alt="image-20240516084147421"><figcaption aria-hidden="true">image-20240516084147421</figcaption></figure></li></ol></li><li><p>找出迫切循环</p><p>简单循环—每个状态只出现一次的等待时间循环。</p><p>迫切循环是指从各自初始状态输出的边缘都具有最小等待时间的简单循环，即平均等待时间比其他等待时间更小。</p><p>平均间隔拍数，也称为平均启动距离</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516084510141.png" alt="image-20240516084510141"><figcaption aria-hidden="true">image-20240516084510141</figcaption></figure></li></ul><h4 id="超标量超流水">超标量/超流水</h4><table><thead><tr class="header"><th>机器类型</th><th><em>k</em>段流水线基准标量处理机</th><th><em>m</em>度超标量处理机</th><th><em>n</em>度超流水线处理机</th><th>(<em>m</em>, <em>n</em>)度超标量超流水线处理机</th></tr></thead><tbody><tr class="odd"><td>机器流水线周期</td><td>1个时钟周期</td><td>1</td><td>1/<em>n</em></td><td>1/<em>n</em></td></tr><tr class="even"><td>同时发射指令条数</td><td>1条</td><td><em>m</em></td><td>1</td><td><em>m</em></td></tr><tr class="odd"><td>指令发射等待时间</td><td>1个时钟周期</td><td>1</td><td>1/<em>n</em></td><td>1/<em>n</em></td></tr><tr class="even"><td>指令级并行度（ILP）</td><td>1</td><td><em>m</em></td><td><em>n</em></td><td><em>m</em>×<em>n</em></td></tr></tbody></table><h4 id="多流水线调度">多流水线调度</h4><p>顺序发射，资源相关</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516102305939.png" alt="image-20240516102305939"><figcaption aria-hidden="true">image-20240516102305939</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516110725201.png" alt="image-20240516110725201"><figcaption aria-hidden="true">image-20240516110725201</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516110732757.png" alt="image-20240516110732757"><figcaption aria-hidden="true">image-20240516110732757</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516110739321.png" alt="image-20240516110739321"><figcaption aria-hidden="true">image-20240516110739321</figcaption></figure><h2 id="五并行处理机">五、并行处理机</h2><h4 id="并行性概念">并行性概念</h4><p>在同一时刻或同一时间间隔内完成两种或两种以上的性质相同或不同的工作，只要在时间上相互重叠，均存在并行性。</p><ul><li><p>同时性：两个或多个事件在<strong>同一时刻</strong>发生的并行性</p></li><li><p>并发性：两个或多个事件在<strong>同一时间间隔</strong>内发生的并行性</p></li></ul><h4 id="并行性等级">并行性等级</h4><ul><li><p>从执行角度</p><ul><li><p>指令内部并行：指令内部的微操作之间的并行</p></li><li><p>指令间并行：并行执行两条或多条指令</p></li><li><p>任务级或过程级并行：并行执行两个或多个过程或任务（程序段）</p></li><li><p>作业或程序级并行：在多个作业或程序间的并行</p></li></ul></li><li><p>从数据处理角度</p><ul><li>字串位串：同时只对一个字的一位进行处理，不存在并行性</li><li>字串位并：同时对一个字的所有位进行处理，</li><li>字并位串：同时对多个字的同一位进行处理</li><li>字并位并：同时对多个字的所有位或部分位进行同时处理</li></ul></li></ul><h4 id="提高并行性的三条途径">提高并行性的三条途径</h4><ul><li><p>时间重叠</p><ul><li><p>流水线</p></li><li><p>多个处理过程在时间上相互错开，轮流重叠使用同一套硬件的各个部件，以加快部件的周转而提高速度。时间重叠原则上不要求重复的硬件设备</p></li></ul></li><li><p>资源重复</p><ul><li>重复设置多个硬件部件以提高计算机系统的性能</li></ul></li><li><p>资源共享</p><ul><li>分时系统、分布式系统。利用软件方法，使多个用户分时使用同一个计算机系统。</li></ul></li></ul><h4 id="并行处理机simd定义">并行处理机（SIMD）定义</h4><p>多个处理部件按照一定方式互联，在同一个控制部件控制下，对各自的数据完成同一条指令规定的操作</p><h4 id="单级互连函数">单级互连函数</h4><ul><li><p>交换互联网络（立方体单级网络）Cube</p><ul><li><p>出端编码与连接的入端结点的编码有一位相反</p><p><span class="math inline">\(\mathrm{Cube_0=(b_2b_1b_0)~;~Cube_1=(b_2\overline{b_1}b_0)~;}\)</span></p></li></ul></li><li><p>全混洗网络 Perfect Shuffle</p><ul><li><p>把二进制结点号循环左移一位</p><p><span class="math inline">\(S(x_{n-1}x_{n-2}\cdotsx_1x_0)=x_{n-2}x_{n-3}\cdots x_1x_0x_{n-1}\)</span></p></li><li><p>子混洗S<sub>(k)</sub>,最低k位循环左移一位</p><p><span class="math inline">\(S_{\mathrm{(k)}}(\mathrm{x_{n-1}x_{n-2}\cdotsx_{k}x_{k-1}x_{k-2}\cdots x_{1}x_{0}})=\mathrm{x_{n-1}x_{n-2}\cdotsx_{k}x_{k-2}\cdots x_{1}x_{0}x_{k-1}}\)</span></p></li><li><p>超混洗S<sup>(k)</sup>,最高k位循环左移一位</p><p><span class="math inline">\(S^{(\mathrm{k})}(\mathrm{X_{n-1}X_{n-2}\cdotsX_{n-k}X_{n-k-1}\cdots X_1X_0})=\mathrm{X_{n-2}\cdotsX_{n-k}X_{n-1}X_{n-k-1}\cdots X_1X_0}\)</span></p></li><li><p>逆混洗S<sup>-1</sup>,右移一位</p><p><span class="math inline">\(S^{-1}(x_{n-1}x_{n-2}\cdotsx_1x_0)=x_0x_{n-1}x_{n-2}\cdots x_1\)</span></p></li></ul></li><li><p>移数函数 PM2I</p><ul><li><p>输入端向量循环移动一定的位置</p><p><span class="math inline">\(\begin{aligned}&amp;\mathrm{PM2I_{+i}(j)=(j+2^i)~mod~N;}\\&amp;\mathrm{n=log_2N,0\leqi\leq n-1,}\\&amp;\mathrm{PM2I_{-i}(j)=(j-2^i)~mod~N;\quad0\leq j\leqN-1}\end{aligned}\)</span></p></li></ul></li><li><p>蝶式函数 Butterfly</p><ul><li><p>最高位和最低位互换位置</p><p><span class="math inline">\(B(x_{n-1}x_{n-2}\cdotsx_1x_0)=x_0x_{n-2}\cdots x_1x_{n-1}\)</span></p></li></ul></li><li><p>反位序 Bit Reversal</p><ul><li><p>将二进制自变量的位序反过来</p><p><span class="math inline">\(R(x_{n-1}x_{n-2}\cdotsx_1x_0)=x_0x_1\cdots x_{n-2}x_{n-1}\)</span></p></li></ul></li></ul><h4 id="多级互连网络">多级互连网络</h4><h5 id="多级立方体网络staran">多级立方体网络STARAN</h5><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516134953200.png" alt="image-20240516134953200"><figcaption aria-hidden="true">image-20240516134953200</figcaption></figure><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516135049249.png" alt="image-20240516135049249"><figcaption aria-hidden="true">image-20240516135049249</figcaption></figure><h5 id="多级混洗交换网络omega网络">多级混洗交换网络（Omega网络）</h5><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516135938533.png" alt="image-20240516135938533"><figcaption aria-hidden="true">image-20240516135938533</figcaption></figure><h4 id="多处理机mimd定义">多处理机（MIMD）定义</h4><ul><li>包含两个或两个以上功能大致相同的处理器；</li><li>所有处理器共享一个公共内存；</li><li>所有处理器共享I/O通道、控制器和外围设备；</li><li>整个系统由统一的操作系统控制，在处理器和程序之间实现作业、任务、程序段、数组和数组元素等各级的全面并行。</li></ul><h4 id="互连网络">互连网络</h4><h5 id="无阻塞交叉开关">无阻塞交叉开关</h5><p>当不断增加总线数目时，使得每个存储器模块都有它自己单独可用的通路。由于每个存储器模块有其自己的总线，所以交叉开关实现了存储器模块的全连接。</p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516185143659.png" alt="image-20240516185143659"><figcaption aria-hidden="true">image-20240516185143659</figcaption></figure><h5 id="多端口存储器">多端口存储器</h5><p>把分布在交叉开关矩阵网络上的控制、转接、优先级仲裁等逻辑功能转移到存储器模块的接口上，就形成了多端口存储器系统。</p><p><strong>多端口存储器可不使用互联网络</strong></p><figure><img src="/2024/05/17/Computer-System-Architecture-Review/image-20240516185204905.png" alt="image-20240516185204905"><figcaption aria-hidden="true">image-20240516185204905</figcaption></figure><h4 id="多处理机系统的cache校验">多处理机系统的cache校验</h4><ol type="1"><li><p>静态一致性校验</p><p>基本思想是：只让该进程的<strong>独用信息（指令和操作数据）</strong>和<strong>共享只读信息</strong>进入本处理机的cache，而不准共享可写（即可修改）信息进入cache，让其只留在<strong>主存</strong>中。</p></li><li><p>动态一致性校验</p><p>基本思想是，在若干cache中使同一个信息（指令、数据）始终保持动态一致。</p><p>•广播法</p><p>•目录法</p></li></ol><h4 id="并行编译">并行编译</h4><p>有下列表达式： Z=E+A*B*C/D+F</p><p>利用普通串行编译算法，产生三元指令组为</p><p>​ 1 *AB</p><p>​ 2 *1C</p><p>​ 3 /2D</p><p>​ 4 +3E</p><p>​ 5 +4F</p><p>​ 6 =5Z</p><p>指令间均相关，需5级运算。</p><p>如采用并行编译算法可得：</p><p>​ 1 *AB 2 /CD</p><p>​ 3 *12 4 +EF</p><p>​ 5 +34</p><p>​ 6 =5Z</p><p>1、2为第一级；3、4为第二级；5、6为第三级；</p><p>分配给两个处理机，只需三级运算。</p><h2 id="六集群网格云计算">六、集群、网格、云计算</h2><h4 id="集群计算机分类">集群计算机分类</h4><ul><li>高可用性（High Availability）集群：致力于提供高度可靠的服务</li><li>负载均衡（LoadBalance）集群：使任务在集群中尽可能平均地分摊到不同的计算节点处理，提高对任务的处理效率</li><li>高性能计算（High PerformanceComputing）集群：把一个问题的计算任务分配到多个计算节点上，利用这些计算节点的资源来完成任务，从而完成单机不能胜任的工作</li></ul><h4 id="mpi并行编程">MPI并行编程</h4><p>最基本的MPI函数：</p><p><strong>(1) MPI_Init(); 初始化MPI环境</strong></p><p><strong>(2) MPI_Comm_size(); 获取进程数量</strong></p><p><strong>(3) MPI_Comm_rank(); 获取本进程进程号</strong></p><ol start="4" type="1"><li>MPI_Finalize(); 退出MPI环境</li></ol><p><strong>(5) MPI_Send(); 点对点发送信息</strong></p><p><strong>(6) MPI_Recv(); 点对点接收信息</strong></p><ol start="7" type="1"><li><p>MPI_Bcast()； 广播</p></li><li><p>MPI_Reduce()； 规约</p></li><li><p>MPI_Gather()； 收集</p></li><li><p>MPI_Scatter()； 散发</p></li><li><p>MPI_Barrier()； 同步</p></li></ol><h4 id="云计算特点">云计算特点</h4><ol type="1"><li>超大规模和廉价性</li><li>虚拟化</li><li>高可靠性</li><li>通用性</li><li>高可扩展性（弹性）</li><li>按需服务</li></ol><h2 id="简答">简答</h2><ol type="1"><li><p>CISC &amp; RISC</p><ul><li><p>复杂指令系统CISC</p><ul><li>提供复杂指令来提高性能</li><li>所含指令至少300条，甚至超过500条</li><li>设计目的：用最少的机器语言指令来完成所需的计算任务</li><li>使得硬件越来越复杂，<strong>造价相应提高</strong>，复杂的指令系统不但不容易实现，<strong>还可能降低性能</strong></li></ul></li><li><p>精简指令系统RISC</p><ul><li><p>只保留使用频率很高的少量指令</p></li><li><p>其他复杂功能通过组合指令（子程序）实现</p></li><li><p>提供一些必要的指令以支持OS和高级语言</p></li><li><p>寻址方式不够灵活</p></li></ul></li></ul></li><li><p>CUDA</p><ul><li>CUDA编程基于<strong>SIMD编程模型</strong>。执行核函数之前，用户需要（手动）将数据通过PCI-E通道由内存复制到显存中；核函数执行完毕后，用户再将运算后的数据由显存复制回主机的内存中。</li><li>GPU上执行的代码称为<strong>核函数</strong>（kernel）</li></ul><p>CUDA线程的组织：</p><ul><li><p><strong>线程</strong>（Thread）：CUDA程序的基本执行单元。每个线程内的指令都会顺序执行。遵循SIMD编程模型，所有的线程都会执行相同的代码或相同代码的不同分支。理论上，所有的线程都是并行执行的，没有先后之分。</p></li><li><p><strong>线程块</strong>（Block）：由一组线程组成。每个线程块内部线程之间可以进行协作，有可以共同访问的共享内存。</p><p>CUDA程序执行时，每个线程块会在GPU上同一个SM中执行，每个线程块内的线程又会以线程束(Wrap)为单位，分组在SM中执行。线程束是GPU在执行时调度的最小单位。大小一般为32。</p></li><li><p><strong>网格</strong>（Grid）：一组线程块的集合。网格里的线程块会被调度到GPU的多个SM上去执行。线程块之间没有同步机制，执行的先后顺序不确定。</p></li></ul></li><li><p>并行处理机</p><p>多个处理部件按照一定方式互联，在同一个控制部件控制下，对各自的数据完成同一条指令规定的操作。</p><ul><li><p>在单机系统里主要是采用时间重叠技术。把一件工作按功能分割为若干相互联系的部分，把每一部分指定给专门的部件完成，然后按时间重叠原则把各部分执行过程在时间上重叠起来，使所有部件依次分工完成一组同样的工作。</p></li><li><p>并行处理机主要是通过资源重复技术来实现并行处理的。它属于单指令流多数据流（SIMD）计算机一类。</p></li><li><p>从控制部件角度看，指令是串行执行的</p></li><li><p>从处理部件角度看，数据是并行处理的</p></li></ul><p><strong>提高并行性的三条途径</strong></p><ul><li><p>时间重叠</p><ul><li><p>流水线</p></li><li><p>多个处理过程在时间上相互错开，轮流重叠使用同一套硬件的各个部件，以加快部件的周转而提高速度。时间重叠原则上不要求重复的硬件设备</p></li></ul></li><li><p>资源重复</p><ul><li>重复设置多个硬件部件以提高计算机系统的性能</li></ul></li><li><p>资源共享</p><ul><li>分时系统、分布式系统。利用软件方法，使多个用户分时使用同一个计算机系统。</li></ul></li></ul></li><li><p>并行性等级</p><ul><li><p>从执行角度</p><ul><li><p>指令内部并行：指令内部的微操作之间的并行</p></li><li><p>指令间并行：并行执行两条或多条指令</p></li><li><p>任务级或过程级并行：并行执行两个或多个过程或任务（程序段）</p></li><li><p>作业或程序级并行：在多个作业或程序间的并行</p></li></ul></li><li><p>从数据处理角度</p><ul><li><p>字串位串：同时只对一个字的一位进行处理，不存在并行性</p></li><li><p>字串位并：同时对一个字的所有位进行处理，</p></li><li><p>字并位串：同时对多个字的同一位进行处理</p></li><li><p>字并位并：同时对多个字的所有位或部分位进行同时处理</p></li></ul></li></ul></li><li><p>MPI</p><p>集群计算机分类</p><ul><li><p>高可用性（HighAvailability）集群：致力于提供高度可靠的服务</p></li><li><p>负载均衡（LoadBalance）集群：使任务在集群中尽可能平均地分摊到不同的计算节点处理，提高对任务的处理效率</p></li><li><p>高性能计算（High PerformanceComputing）集群：把一个问题的计算任务分配到多个计算节点上，利用这些计算节点的资源来完成任务，从而完成单机不能胜任的工作</p></li></ul><p>最基本的MPI函数：</p><p><strong>(1) MPI_Init(); 初始化MPI环境</strong></p><p><strong>(2) MPI_Comm_size(); 获取进程数量</strong></p><p><strong>(3) MPI_Comm_rank(); 获取本进程进程号</strong></p><ol start="4" type="1"><li>MPI_Finalize(); 退出MPI环境</li></ol><p><strong>(5) MPI_Send(); 点对点发送信息</strong></p><p><strong>(6) MPI_Recv(); 点对点接收信息</strong></p></li><li><p>虚拟存储系统</p><p>虚拟存储器是指“主存-辅存”层次，它能使该层次具有辅存容量、接近主存的等效速度和辅存的每位成本，使程序员可以按比主存大得多的虚拟存储空间编写程序（即按虚存空间编址）</p><p>Cache的主要作用是弥补主存和CPU之间的速度差距，因此它的管理部件是用硬件实现的，并对程序员透明。</p><p>但虚拟存储器的主要作用是弥补主存和辅存之间的容量差距，因此它的管理部件基本上靠软件，适当结合硬件来实现，对系统程序员也不是透明的。</p></li><li><p>流水技术特点</p><ol type="1"><li>可以划分为若干互有联系的子过程（功能段）。每个功能段由专用功能部件实现。</li><li>实现功能段所需的时间应尽可能相等，避免因不等产生处理瓶颈，造成“断流”。</li><li>形成流水线处理，需要一段准备时间，称为“通过时间”。只有在此之后流水过程才能稳定。</li><li>指令流不能顺序执行时，会使流水过程中断；再形成流水过程，则需经过一段时间。不应经常“断流”，否则效率不高。</li><li>流水线技术适用于大量重复的程序过程，只有输入端能连续提供服务，流水线效率才能够得到充分发挥。</li></ol></li></ol><p>8.并行存储器</p><p>高位交叉</p><ol type="1"><li><p>目的：扩大存储容量</p></li><li><p>实现方法：用地址码的高位部分区分存储体号</p></li><li><p>特点：</p><ul><li><p>具备并行工作的条件：每个存储模块有各自独立的控制部件，包括地址寄存器、地址译码器等，可以独立工作</p></li><li><p>编址的连续性：由于程序的连续性和局部性，大部分情况下，指令序列和数据分布在同一个存储模块中。只有当指令序列跨越两个存储模块时，才能并行工作</p></li><li><p><strong>扩大容量，未提高速度</strong></p></li></ul></li></ol><p>低位交叉(多体交叉编址)</p><ol type="1"><li>目的：提高存储器访问速度</li><li>实现方法：用地址码的低位部分区分存储体号</li><li>虽然多体并行主存系统和单体并行主存系统最大频宽可以相同，但多体地址可以灵活设置，只要是在不同分体中，就能得到比单体更高的频宽。因为程序常有转移出现，使得实际访问地址不一定均匀分布在交叉分体上，致使效率下降。统计表明，采用多体并行主存结构的计算机系统获得的实际频宽约是最大理想频宽的1/3。</li><li>特点：<ul><li>存储体的访问周期T<sub>m</sub>，由<em>n</em>个存储体构成的主存储器，各存储体的启动间隔$t=T_m/n$</li><li>低位交叉存储器是一种采用<strong>分时工作</strong>工作的并行存储系统。在连续工作的情况下，保持每个存储体速度不变，则整个存储器速度可望提高<em>n</em>倍</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统结构</tag>
      
      <tag>期末复习知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
